{"version":3,"sources":["contrib/uri.cljc"],"mappings":";AAWA,AAqCA,wBAAA,xBAAMC,wDAAWC,EAAEC;AAAnB,AAAA,GACS,AAACC,qBAAKF;AADf;AAAA,AAAA,MAAA,KAAAF,MAAA;;;AAEE,IAAMK,UAAQ,0EAAA,xEAEa,cAAWC,bAASJ,wBAAG,4CAAKA;AAFvD,AAGE,OAAsBK,iBAAQJ,EAAE,CAAA,uBAAA,RAAoBE;;AAO/C,AAAA,CAAA,AAAA,iDAAAG,jDAAaF;;AAAb,CAAA,AAAA,AAAaA,mEAA0B,WAAaJ,EAAEO,OAAOC;AAAtB,AAAA,YAAA,RAAaR;AAAb,AAAyB,OAACD,sBAAUC,MAAEO;;AAKtF,AAWA,AAcA,AAYA,AASA,AAOA,AAMA","names":["js/Error","contrib.uri/print-uri","o","w","cljs.core/uri?","str-rep","js/goog.Uri","cljs.core/-write","cljs.core/PROTOCOL_SENTINEL","writer","_"],"sourcesContent":["(ns contrib.uri\r\n  (:require clojure.edn\r\n            #?(:cljs goog.Uri)\r\n            [hyperfiddle.rcf :refer [tests]]))\r\n\r\n;(defmacro tests [& body])\r\n\r\n; clojure.core/uri? builtin hardcodes java.net.URI and goog.Uri\r\n; transit-java, transit-js \u2013 OOTB read as dummy URI type (concrete type is deferred to language impl per transit design)\r\n; transit-clj, transit-cljs \u2013 OOTB read as dummy URI type!! they do not align to clojure.core/uri? ootb!\r\n\r\n(comment\r\n  ; tests disabled because once this extension ns is loaded, they no longer pass\r\n  ; (and cljs will auto-load this ns due to data_loaders.cljc)\r\n  #?(:clj (tests\r\n            \"document java.net.URI OOTB behavior\"\r\n            (def jx (java.net.URI. \"http://localhost:8080/a?b#c\"))\r\n            (str jx) := \"http://localhost:8080/a?b#c\"\r\n            (pr-str jx) := \"#object[java.net.URI 0x5cbf50ff \\\"http://localhost:8080/a?b#c\\\"]\"\r\n            (uri? jx) := true\r\n            (= (java.net.URI. \"http://localhost:8080/a?b#c\")\r\n              (java.net.URI. \"http://localhost:8080/a?b#c\")) := true\r\n            ;(= #user/uri \"http://localhost:8080/a?b#c\" jx) := true -- compiler error\r\n            (= (read-string \"#user/uri \\\"http://localhost:8080/a?b#c\\\"\") jx) :throws Exception)\r\n     :cljs (tests\r\n             \"document goog.Uri OOTB behavior\"\r\n             (def gx (goog.Uri. \"http://localhost:8080/a?b#c\"))\r\n             (str gx) := \"http://localhost:8080/a?b#c\" ; str repr\r\n             (pr-str gx) := \"#object[Object http://localhost:8080/a?b#c]\" ; needs edn extension\r\n             (uri? gx) := true\r\n             (= (goog.Uri. \"http://localhost:8080/a?b#c\")\r\n               (goog.Uri. \"http://localhost:8080/a?b#c\")) := false\r\n             ;(= #user/uri \"http://localhost:8080/a?b#c\" jx) := true -- compiler error\r\n             (= (cljs.reader/read-string \"#user/uri \\\"http://localhost:8080/a?b#c\\\"\") jx) :throws js/Error)))\r\n\r\n; clojure code literals\r\n; clojure runtime literals\r\n; cljs code literals\r\n; cljs runtime literals use EDN reader, because the js runtime is unsafe\r\n; clojure.edn (clojure/script)\r\n; tools.edn (clojure/script)\r\n\r\n; We decline to implement the transit dummy URI types, see https://github.com/cognitect/transit-cljs/issues/16\r\n; https://github.com/cognitect/transit-clj/blob/master/src/cognitect/transit.clj\r\n; https://github.com/cognitect/transit-cljs/blob/master/src/cognitect/transit.cljs\r\n; https://github.com/cognitect/transit-java/blob/master/src/main/java/com/cognitect/transit/URI.java\r\n; https://github.com/cognitect/transit-js/blob/9c28b4d9afaddae3cf15073296fcd736f68600a9/src/com/cognitect/transit/types.js#L36\r\n\r\n(defn print-uri [o w]\r\n  {:pre [(uri? o)]}\r\n  (let [str-rep (cond\r\n                  #?@(:clj ((instance? java.net.URI o) (str o))\r\n                      :cljs ((instance? goog.Uri o) (str o))))]\r\n    (#?(:clj .write :cljs -write) w (str \"#user/uri \\\"\" str-rep \"\\\"\"))))\r\n\r\n; FAQ: The reader docs say that custom literals should be namespaced to avoid name collisions with\r\n; core, why is `uri` unqualified here? https://clojure.org/reference/reader\r\n; A: we think this should be in core, in alignment with clojure.core/uri? being hardcoded to\r\n; java.net.URI and goog.Uri, they are not userland types.\r\n\r\n#?(:cljs (extend-type goog.Uri IPrintWithWriter (-pr-writer [o writer _] (print-uri o writer))))\r\n#?(:clj (defmethod print-method java.net.URI [o ^java.io.Writer w] (print-uri o w)))\r\n#?(:clj (defmethod print-dup java.net.URI [o ^java.io.Writer w] (print-uri o w)))\r\n;#?(:clj (defmethod print-method com.cognitect.transit.URI [o ^java.io.Writer w] (print-uri o w)))\r\n\r\n(tests\r\n  (def x #?(:clj (java.net.URI. \"http://localhost:8080/a?b#c\")\r\n            :cljs (goog.Uri. \"http://localhost:8080/a?b#c\")))\r\n  (str x) := \"http://localhost:8080/a?b#c\" ; unchanged\r\n  (pr-str x) := \"#user/uri \\\"http://localhost:8080/a?b#c\\\"\")\r\n\r\n; for data_readers.cljc\r\n#?(:clj (defn uri-clj-reader [s] (java.net.URI. s)))\r\n#?(:clj (defn uri-cljs-reader [s] `(goog.Uri. ~s))) ; called from cljs compiler jvm\r\n; https://github.com/clojure/clojurescript/commit/5379f722588370f9f1934e9a78e777e24e953c81\r\n\r\n(tests\r\n  \"#user/uri code literals are auto-wired from data_readers.cljc\"\r\n  (def x #user/uri \"http://localhost:8080/a?b#c\")\r\n  (uri? x) := true\r\n  (str x) := \"http://localhost:8080/a?b#c\"\r\n  (pr-str x) := \"#user/uri \\\"http://localhost:8080/a?b#c\\\"\"\r\n\r\n  \"note goog.Uri is mutable, so no equality in cljs\"\r\n  (= #user/uri \"http://localhost:8080/a?b#c\"\r\n    #user/uri \"http://localhost:8080/a?b#c\") := #?(:clj true :cljs false))\r\n\r\n\r\n; Readers\r\n\r\n(tests\r\n  \"clj #user/uri runtime literal readers are auto-wired in clojure from data_readers.cljc\"\r\n  #?@(:clj ((clojure.core/read-string \"#user/uri \\\"http://localhost:8080/a?b#c\\\"\") := x))\r\n\r\n  \"cljs #user/uri runtime literals are NOT auto-wired in cljs reader (the cljs JS runtime reader is always an\r\n  EDN reader for safety, unlike clj)\"\r\n  ; https://www.clojurescript.org/guides/reader\r\n  #?@(:cljs ((cljs.reader/read-string \"#user/uri \\\"http://localhost:8080/a?b#c\\\"\")\r\n             :throws js/Error ; No reader function for tag uri.\r\n             (contains? (set (keys @cljs.reader/*tag-table*)) 'inst) := true\r\n             (contains? (set (keys @cljs.reader/*tag-table*)) 'uri) := false)))\r\n\r\n(tests\r\n  \"control - clojure.edn\"\r\n  #?@(:clj ((clojure.edn/read-string \"1\") := 1)\r\n      :cljs ((clojure.edn/read-string \"1\") := 1))\r\n\r\n  \"edn readers don't auto-wire the unsafe code literals\"\r\n  #?@(:clj ((clojure.edn/read-string \"#user/uri \\\"http://localhost:8080/a?b#c\\\"\") :throws RuntimeException)\r\n      :cljs ((clojure.edn/read-string \"#user/uri \\\"http://localhost:8080/a?b#c\\\"\") :throws js/Error)))\r\n\r\n(tests\r\n  \"#user/uri direct edn reader configuration - different for clj and cljs\"\r\n  (def edn-read-str (partial clojure.edn/read-string {:readers {'user/uri #?(:clj #(java.net.URI. %)\r\n                                                                             :cljs #(goog.Uri. %))}}))\r\n  (edn-read-str \"#user/uri \\\"http://localhost:8080/a?b#c\\\"\")\r\n  (uri? *1) := true)\r\n\r\n(comment\r\n  (tests\r\n    \"cljs userland can globally register an EDN tag reader, but it's probably a bad idea\"\r\n    #?@(:cljs ((cljs.reader/register-tag-parser! 'uri #(goog.Uri. %))\r\n               (clojure.edn/read-string \"#user/uri \\\"http://localhost:8080/a?b#c\\\"\") := x))))\r\n\r\n(tests\r\n  \"clj userland can not globally register an EDN tag reader\"\r\n  #?@(:clj ((clojure.edn/read-string \"#user/uri \\\"http://localhost:8080/a?b#c\\\"\") :throws RuntimeException)))\r\n\r\n; for easy portable config \u2013 optional\r\n;(defn uri-edn-reader [s] #?(:clj (java.net.URI. s) :cljs (goog.Uri. s)))\r\n;\r\n;(tests\r\n;  \"#user/uri easy portable config \u2013 same for clj and cljs\"\r\n;  (clojure.edn/read-string {:readers {'uri uri-edn-reader}} \"#user/uri \\\"http://localhost:8080/a?b#c\\\"\")\r\n;  (uri? *1) := true)\r\n"]}