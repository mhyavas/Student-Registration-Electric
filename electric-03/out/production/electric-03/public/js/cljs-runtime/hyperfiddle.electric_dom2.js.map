{"version":3,"sources":["hyperfiddle/electric_dom2.cljc"],"mappings":"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","names":["hyperfiddle.electric-dom2/nil-subject","!","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","hyperfiddle.electric-dom2/unsupported","seq34281","self__5755__auto__","cljs.core/seq","_","cljs.core.ex_info","hyperfiddle.electric-dom2/hook","x","G__34282","y","hyperfiddle.electric-dom2/by-id","id","js/document.getElementById","hyperfiddle.electric-dom2/new-node","parent","type","el","G__34283","cljs.core/Keyword","js/document","goog.dom/createTextNode","goog.dom/createElement","hyperfiddle.electric-dom2/-googDomSetTextContentNoWarn","node","str","goog.dom/setTextContent","hyperfiddle.electric-dom2/SVG-NS","hyperfiddle.electric-dom2/XLINK-NS","hyperfiddle.electric-dom2/alias->ns","hyperfiddle.electric-dom2/attr-alias","attr","cljs.core/second","cljs.core/re-find","cljs.core/name","hyperfiddle.electric-dom2/resolve-attr-alias","temp__5802__auto__","alias","clojure.string/replace-first","G__34285","hyperfiddle.electric-dom2/set-attribute-ns","js/Error","v","vec__34286","cljs.core.nth","ns","hyperfiddle.electric_dom2.set_attribute_ns","G__34290","hyperfiddle.electric-dom2/set-property!","k","hyperfiddle.electric_dom2.set_property_BANG_","cljs.core/clj->js","and__5043__auto__","G__34291","goog.style/setStyle","hyperfiddle.electric_dom2.goog$module$goog$object.get","goog.dom/DIRECT_ATTRIBUTE_MAP_","cljs.core._EQ_","hyperfiddle.electric_dom2.goog$module$goog$object.containsKey","hyperfiddle.electric_dom2.goog$module$goog$object.set","hyperfiddle.electric-dom2/unmount-prop","missionary.core/observe","hyperfiddle.electric-dom2/LAST-PROPS","hyperfiddle.electric-dom2/ordered-props","props-map","props","cljs.core.apply","cljs.core/dissoc","cljs.core.concat","cljs.core/select-keys","hyperfiddle.electric-dom2/parse-class","xs","G__34293","clojure.string.split","cljs.core/coll?","cljs.core.into","cljs.core.comp","cljs.core.filter","cljs.core/string?","cljs.core.remove","clojure.string/blank?","hyperfiddle.electric-dom2/register-class!","class","refs","or__5045__auto__","cljs.core.update","cnt","hyperfiddle.electric-dom2/unregister-class!","cljs.core.get","cljs.core.dissoc","cljs.core/dec","hyperfiddle.electric-dom2/set-val"],"sourcesContent":["(ns hyperfiddle.electric-dom2\n  (:refer-clojure :exclude [time])\n  (:require [contrib.missionary-contrib :as mx]\n            #?(:cljs goog.dom)\n            #?(:cljs goog.object)\n            #?(:cljs goog.style)\n            [hyperfiddle.electric :as e]\n            [missionary.core :as m]\n            [clojure.string :as str]\n            [contrib.data :as data])\n  (:import [hyperfiddle.electric Pending])\n  #?(:cljs (:require-macros [hyperfiddle.electric-dom2 :refer [with]])))\n\n(e/def node)\n(def nil-subject (fn [!] (! nil) #()))\n(e/def keepalive (new (m/observe nil-subject)))\n\n(defn unsupported [& _]\n  (throw (ex-info (str \"Not available on this peer.\") {})))\n\n(def hook \"See `with`\"\n  #?(:clj  unsupported\n     :cljs (fn ([x] (some-> (.-parentNode x) (.removeChild x)))\n             ([x y] (.insertBefore (.-parentNode x) x y))))) ; rotate siblings\n\n(defmacro with\n  \"Attach `body` to a dom node, which will be moved in the DOM when body moves in the DAG.\n  Given p/for semantics, `body` can only move sideways or be cancelled. If body is cancelled,\n  the node will be unmounted. If body moves, the node will rotate with its siblings.\"\n  [dom-node & body]\n  `(binding [node ~dom-node]\n     ; wrap body in a constant frame, so it can be moved as a block\n     (new (e/hook hook node (e/fn [] keepalive ~@body))))) ; todo remove\n\n#?(:cljs (defn by-id [id] (js/document.getElementById id)))\n\n#?(:cljs\n   (defn new-node [parent type]\n     (let [el (case type\n                :comment (.createComment js/document \"\")\n                :text (goog.dom/createTextNode \"\")\n                (goog.dom/createElement type))]\n       (.appendChild parent el)\n       el)))\n\n(defmacro element [t & body]\n  `(with (new-node node ~(name t))\n     ; hack: speed up streamy unmount by removing from layout first\n     ; it also feels faster visually\n     (e/on-unmount #(set! (.. node -style -display) \"none\")) ; hack\n     ~@body))\n\n#?(:cljs (defn -googDomSetTextContentNoWarn [node str]\n           ; Electric says :infer-warning Cannot infer target type in expression, fixme\n           (goog.dom/setTextContent node str)))\n\n(defmacro text [& strs]\n  `(do (assert (not= (.-nodeType node) (.-TEXT_NODE node))\n               \"userland directed dom/text inside dom/text, which is illegal\")\n       ~@(map (fn [str]\n                `(with (new-node node :text)\n                   (-googDomSetTextContentNoWarn node ~str)))\n           strs)))\n\n(defmacro comment_ [& strs]\n  (cons `do\n    (map (fn [str] `(with (new-node node :comment)\n                      (-googDomSetTextContentNoWarn node ~str)))\n      strs)))\n\n(def ^:const SVG-NS \"http://www.w3.org/2000/svg\")\n(def ^:const XLINK-NS \"http://www.w3.org/1999/xlink\")\n\n(def alias->ns {\"svg\" SVG-NS, \"xlink\" XLINK-NS})\n\n(defn attr-alias [attr] (second (re-find #\"^([^:]+):\" (name attr))))\n\n(defn resolve-attr-alias [attr]\n  (let [attr (name attr)]\n    (if-let [alias (attr-alias attr)]\n      (let [attr (-> (str/replace-first attr alias \"\")\n                   (str/replace-first #\"^:\" \"\"))]\n        [(alias->ns alias) attr])\n      [nil attr])))\n\n#?(:cljs\n   (defn set-attribute-ns\n     ([node attr v]\n      (let [[ns attr] (resolve-attr-alias attr)]\n        (set-attribute-ns node ns attr v)))\n     ([^js node ns attr v]\n      (.setAttributeNS node ns attr v))))\n\n#?(:cljs\n   (defn set-property!\n     ([node k v] (set-property! node (.-namespaceURI node) k v))\n     ([node ns k v]\n      (let [k (name k)\n            v (clj->js v)]\n        (if (and (nil? v) (.hasAttributeNS node nil k))\n          (.removeAttributeNS node nil k)\n          (case k\n            \"style\" (goog.style/setStyle node v)\n            \"list\"  (set-attribute-ns node nil k v) ; corner case, list (datalist) is setted by attribute and readonly as a prop.\n            (if-let [k (goog.object/get goog.dom/DIRECT_ATTRIBUTE_MAP_ k)]\n              (set-attribute-ns node k v)\n              (if (= SVG-NS ns)\n                (set-attribute-ns node k v)\n                (if (goog.object/containsKey node k) ; is there an object property for this key?\n                  (goog.object/set node k v)\n                  (set-attribute-ns node k v))))))))))\n\n#?(:cljs (defn unmount-prop [node k v]\n           (m/observe (fn [!] (! nil) #(set-property! node k v)))))\n\n(defmacro style [m]\n  (if (map? m)\n    `(do ~@(mapcat (fn [[k v]] [`(set-property! node \"style\" {~k ~v})\n                                `(new (unmount-prop node \"style\" {~k nil}))]) m)\n         nil) ; static keyset\n    `(e/for-by first [sty# (vec ~m)]\n       (set-property! node \"style\" {(key sty#) (val sty#)})\n       (new (unmount-prop node {(key sty#) nil}))\n       nil)))\n\n\n(def LAST-PROPS\n  \"Due to a bug in both Webkit and FF, input type range's knob renders in the\n  wrong place if value is set after `min` and `max`, and `max` is above 100.\n  Other UI libs circumvent this issue by setting `value` last.\"\n [:value ::value])\n\n(defn ordered-props \"Sort props by key to ensure they are applied in a predefined order. See `LAST-PROPS`.\"\n  [props-map]\n  (let [props (apply dissoc props-map LAST-PROPS)]\n    (concat (seq props) (seq (select-keys props-map LAST-PROPS)))))\n\n(defn parse-class [xs]\n  (cond (string? xs) (parse-class (str/split xs #\"\\s+\"))\n        (coll? xs)   (into [] (comp (filter string?) (remove str/blank?)) xs)\n        :else        nil))\n\n#?(:cljs\n   (defn register-class! [^js node class]\n     (let [refs (or (.-hyperfiddle_electric_dom2_class_refs node) {})]\n       (.add (.-classList node) class)\n       (set! (.-hyperfiddle_electric_dom2_class_refs node) (update refs class (fn [cnt] (inc (or cnt 0))))))))\n\n#?(:cljs\n   (defn unregister-class! [^js node class]\n     (let [refs (or (.-hyperfiddle_electric_dom2_class_refs node) {})\n           refs (if (= 1 (get refs class))\n                  (do (.remove (.-classList node) class)\n                      (dissoc refs class))\n                  (update refs class dec))]\n       (set! (.-hyperfiddle_electric_dom2_class_refs node) refs))))\n\n(e/defn ClassList [node classes]\n  (e/for [class classes]\n    (new (m/relieve {} (m/observe (fn [!]\n                                    (! nil)\n                                    (register-class! node class)\n                                    #(unregister-class! node class)))))))\n\n;; TODO JS runtimes intern litteral strings, so call `name` on keywords at\n;; macroexpension.\n(defmacro props [m]\n  (let [style? #{:style ::style}       ; TODO disambiguate\n        class? #{:class ::class}]\n    (if (map? m)\n      `(do ~@(mapcat (fn [[k v]] (cond  ; static keyset\n                                   (style? k) [`(style ~v)]\n                                   (class? k) [`(new ClassList node (parse-class ~v))]\n                                   :else      [`(set-property! node ~k ~v)\n                                          `(new (unmount-prop node ~k nil))]))\n               (ordered-props m))\n           nil)\n      `(e/for-by key [prop# (vec (ordered-props ~m))]\n         (cond\n           (~style? (key prop#)) (style (val prop#))\n           (~class? (key prop#)) (new ClassList node (parse-class (val prop#)))\n           :else                 (do (set-property! node (key prop#) (val prop#))\n                                     (new (unmount-prop node (key prop#) nil))\n                                     nil))))))\n\n(defmacro on!\n  \"Call the `callback` clojure function on event.\n   (on! \\\"click\\\" (fn [event] ...)) \"\n  ([event-name callback] `(on! node ~event-name ~callback))\n  ([dom-node event-name callback] `(on! ~dom-node ~event-name ~callback nil))\n  ([dom-node event-name callback options] \n   `(new (->> (e/listen> ~dom-node ~event-name ~callback ~options)\n           (m/reductions {} nil)))))\n\n(defmacro ^:deprecated ^:no-doc event \"Deprecated, please use `on!`\" [& args] `(on! ~@args))\n(e/def ^:deprecated system-time-ms e/system-time-ms)\n(e/def ^:deprecated system-time-secs e/system-time-secs)\n\n(defmacro on\n  \"Run the given electric function on event.\n  (on \\\"click\\\" (e/fn [event] ...))\"\n  ;; TODO add support of event options (see `event*`)\n  ;(^:deprecated [typ]  `(new Event ~typ false)) ; use `on!` for local side effects\n  ([typ F] `(on node ~typ ~F))\n  ([node typ F] `(binding [node ~node]\n                   (let [[state# v#] (e/for-event-pending-switch [e# (e/listen> node ~typ)] (new ~F e#))]\n                     (case state#\n                       (::e/init ::e/ok) v# ; could be `nil`, for backward compat we keep it\n                       (::e/pending) (throw (Pending.))\n                       (::e/failed)  (throw v#))))))\n\n#?(:cljs (e/def visibility-state \"'hidden' | 'visible'\"\n           (new (->> (e/listen> js/document \"visibilitychange\")\n                  (m/reductions {} nil)\n                  (m/latest #(.-visibilityState js/document))))))\n\n(defmacro on-pending [pending-body & body] `(try (do ~@body) (catch Pending e# ~pending-body (throw e#))))\n\n(e/defn Focused? \"Returns whether this DOM `node` is focused.\"\n  []\n  (->> (mx/mix\n         (e/listen> node \"focus\" (constantly true))\n         (e/listen> node \"blur\" (constantly false)))\n    (m/reductions {} (= node (.-activeElement js/document)))\n    (m/relieve {})\n    new))\n\n#?(:cljs (defn set-val [node v] (set! (.-value node) (str v))))\n\n(defmacro bind-value\n  ([v]        `(bind-value ~v set-val))\n  ([v setter] `(when-some [v# (when-not (new Focused?) ~v)]\n                 (~setter node v#))))\n\n(e/defn Hovered? \"Returns whether this DOM `node` is hovered over.\"\n  []\n  (->> (mx/mix\n         (e/listen> node \"mouseenter\" (constantly true))\n         (e/listen> node \"mouseleave\" (constantly false)))\n    (m/reductions {} false)\n    (m/relieve {})\n    new))\n\n(defmacro a [& body] `(element :a ~@body))\n(defmacro abbr [& body] `(element :abbr ~@body))\n(defmacro address [& body] `(element :address ~@body))\n(defmacro area [& body] `(element :area ~@body))\n(defmacro article [& body] `(element :article ~@body))\n(defmacro aside [& body] `(element :aside ~@body))\n(defmacro audio [& body] `(element :audio ~@body))\n(defmacro b [& body] `(element :b ~@body))\n(defmacro bdi [& body] `(element :bdi ~@body))\n(defmacro bdo [& body] `(element :bdo ~@body))\n(defmacro blockquote [& body] `(element :blockquote ~@body))\n(defmacro br [& body] `(element :br ~@body))\n(defmacro button [& body] `(element :button ~@body))\n(defmacro canvas [& body] `(element :canvas ~@body))\n(defmacro cite [& body] `(element :cite ~@body))\n(defmacro code [& body] `(element :code ~@body))\n(defmacro data [& body] `(element :data ~@body))\n(defmacro datalist [& body] `(element :datalist ~@body))\n(defmacro del [& body] `(element :del ~@body))\n(defmacro details [& body] `(element :details ~@body))\n(defmacro dfn [& body] `(element :dfn ~@body))\n(defmacro dialog [& body] `(element :dialog ~@body))\n(defmacro div [& body] `(element :div ~@body))\n(defmacro dl \"The <dl> HTML element represents a description list. The element encloses a list of groups of terms (specified using the <dt> element) and descriptions (provided by <dd> elements). Common uses for this element are to implement a glossary or to display metadata (a list of key-value pairs).\" [& body] `(element :dl ~@body))\n(defmacro dt \"The <dt> HTML element specifies a term in a description or definition list, and as such must be used inside a <dl> element. It is usually followed by a <dd> element; however, multiple <dt> elements in a row indicate several terms that are all defined by the immediate next <dd> element.\" [& body] `(element :dt ~@body))\n(defmacro dd \"The <dd> HTML element provides the description, definition, or value for the preceding term (<dt>) in a description list (<dl>).\" [& body] `(element :dd ~@body))\n(defmacro em [& body] `(element :em ~@body))\n(defmacro embed [& body] `(element :embed ~@body))\n(defmacro fieldset [& body] `(element :fieldset ~@body))\n(defmacro figure [& body] `(element :figure ~@body))\n(defmacro footer [& body] `(element :footer ~@body))\n(defmacro form [& body] `(element :form ~@body))\n(defmacro h1 [& body] `(element :h1 ~@body))\n(defmacro h2 [& body] `(element :h2 ~@body))\n(defmacro h3 [& body] `(element :h3 ~@body))\n(defmacro h4 [& body] `(element :h4 ~@body))\n(defmacro h5 [& body] `(element :h5 ~@body))\n(defmacro h6 [& body] `(element :h6 ~@body))\n(defmacro header [& body] `(element :header ~@body))\n(defmacro hgroup [& body] `(element :hgroup ~@body))\n(defmacro hr [& body] `(element :hr ~@body))\n(defmacro i [& body] `(element :i ~@body))\n(defmacro iframe [& body] `(element :iframe ~@body))\n(defmacro img [& body] `(element :img ~@body))\n(defmacro input [& body] `(element :input ~@body))\n(defmacro ins [& body] `(element :ins ~@body))\n(defmacro kbd [& body] `(element :kbd ~@body))\n(defmacro label [& body] `(element :label ~@body))\n(defmacro legend [& body] `(element :legend ~@body))\n(defmacro li [& body] `(element :li ~@body))\n(defmacro link [& body] `(element :link ~@body))\n(defmacro main [& body] `(element :main ~@body))\n#_(defmacro map [& body] `(element :map ~@body))\n(defmacro mark [& body] `(element :mark ~@body))\n(defmacro math [& body] `(element :math ~@body))\n(defmacro menu [& body] `(element :menu ~@body))\n(defmacro itemprop [& body] `(element :itemprop ~@body))\n(defmacro meter [& body] `(element :meter ~@body))\n(defmacro nav [& body] `(element :nav ~@body))\n(defmacro noscript [& body] `(element :noscript ~@body))\n(defmacro object [& body] `(element :object ~@body))\n(defmacro ol [& body] `(element :ol ~@body))\n(defmacro option [& body] `(element :option ~@body))\n(defmacro optgroup [& body] `(element :optgroup ~@body))\n(defmacro output [& body] `(element :output ~@body))\n(defmacro p [& body] `(element :p ~@body))\n(defmacro picture [& body] `(element :picture ~@body))\n(defmacro pre [& body] `(element :pre ~@body))\n(defmacro progress [& body] `(element :progress ~@body))\n(defmacro q [& body] `(element :q ~@body))\n(defmacro ruby [& body] `(element :ruby ~@body))\n(defmacro s [& body] `(element :s ~@body))\n(defmacro samp [& body] `(element :samp ~@body))\n(defmacro script [& body] `(element :script ~@body))\n(defmacro section [& body] `(element :section ~@body))\n(defmacro select [& body] `(element :select ~@body))\n(defmacro slot [& body] `(element :slot ~@body))\n(defmacro small [& body] `(element :small ~@body))\n(defmacro span [& body] `(element :span ~@body))\n(defmacro strong [& body] `(element :strong ~@body))\n(defmacro sub [& body] `(element :sub ~@body))\n(defmacro summary [& body] `(element :summary ~@body))\n(defmacro sup [& body] `(element :sup ~@body))\n(defmacro table [& body] `(element :table ~@body))\n(defmacro tbody [& body] `(element :tbody ~@body))\n(defmacro td [& body] `(element :td ~@body))\n(defmacro th [& body] `(element :th ~@body))\n(defmacro thead [& body] `(element :thead ~@body))\n(defmacro tr [& body] `(element :tr ~@body))\n(defmacro template [& body] `(element :template ~@body))\n(defmacro textarea [& body] `(element :textarea ~@body))\n(defmacro time [& body] `(element :time ~@body))\n(defmacro u [& body] `(element :u ~@body))\n(defmacro ul [& body] `(element :ul ~@body))\n(defmacro var [& body] `(element :var ~@body))\n(defmacro video [& body] `(element :video ~@body))\n(defmacro wbr [& body] `(element :wbr ~@body))\n"]}