{"version":3,"sources":["contrib/trace.cljc"],"mappings":";AASA,AAEA,AACA,AACA,AACA,AAuBA,8BAAA,9BAAOA,oEAAeC;AAAtB,AACE;;6BACIC;AADJ,AACc,IAAAC,WAAA,mFAAA,uDAAaD;AAAb,AAAA,8EAAAC,0BAAAA,hGAACF,oCAAAA,8CAAAA;;6BACXG,GAAGC;AAFP,AAEc,IAAAC,WAAA,mFAAA,wDAAaF,GAAGC;AAAhB,AAAA,8EAAAC,0BAAAA,hGAACL,oCAAAA,8CAAAA;;oBAAXG,GAAGC;;;6BAAHD;;6BAAAA,GAAGC;;;;;;;;;AAET,AAsBA,0BAAA,1BAAME;AAAN,AAAmB,IAAMC,UAAG,6CAAA,7CAACC;AAAV,AAAmB,kBAAKC;AAAL,AAAQ,OAACC,mDAAMH,QAAGI;;;AAExD,AASA","names":["contrib.trace/test-listener","tap","point","G__50013","id","trace","G__50014","contrib.trace/monotonic","!t","cljs.core.atom","_","cljs.core.swap_BANG_","cljs.core/inc"],"sourcesContent":["(ns contrib.trace\r\n  (:require\r\n   [hyperfiddle.electric :as e]\r\n   [hyperfiddle.rcf :as rcf :refer [% tap tests with]])\r\n  (:import\r\n   [hyperfiddle.electric Pending]\r\n   [missionary Cancelled])\r\n  #?(:cljs (:require-macros contrib.trace)))\r\n\r\n(e/def listeners '())\r\n(defmacro with-listener [l & body] `(binding [listeners (conj listeners ~l)] ~@body))\r\n(e/def stamp (fn [_]))\r\n(e/def ->point-id (fn [_name _parent-id]))\r\n(e/def ->trace-id (fn [_point-id _v]))\r\n(e/def current nil)\r\n\r\n;; https://github.com/cgrand/macrovich/blob/e80fb37cb795201821d0e75f73119802227e9620/src/net/cgrand/macrovich.cljc\r\n(defmacro macro-case [& {:keys [cljs clj]}]\r\n  (if (contains? &env '&env)\r\n    `(if (:ns ~'&env) ~cljs ~clj)\r\n    (if #?(:clj (:ns &env) :cljs true) cljs clj)))\r\n\r\n(defmacro trace [nm & body]\r\n  `(let [nm# ~nm, id# (->point-id nm# (or current 0)), point# {::point-id id#, ::name nm#, ::parent (or current ::root)}]\r\n     (doseq [l# listeners] (l# point#))\r\n     (let [[typ# v#] (binding [current id#]\r\n                       (try [::ok (do ~@body)]\r\n                            (catch ~(macro-case :clj Throwable :cljs :default) e# [::err e#])))\r\n           trace-id# (->trace-id id# v#)\r\n           stamp# (stamp v#)\r\n           ;; TODO put exception in trace map\r\n           tr# {::trace-id trace-id#, ::stamp stamp#, ::type typ#, ::v v#}]\r\n       (doseq [l# listeners] (l# id# tr#))\r\n       (case typ# ::ok v# #_else (throw v#)))))\r\n\r\n(defmacro trace* [nm & body] `(when current (trace ~nm ~@body)))\r\n\r\n(defn- test-listener [tap]\r\n  (fn\r\n    ([point]    (tap [:point point]))\r\n    ([id trace] (tap [:trace id trace]))))\r\n\r\n(tests \"basic behavior\"\r\n  (with (e/run (try (binding [->point-id #(do (tap [:point-id % %2]) %)\r\n                              stamp (let [!t (atom 0)] (fn [_] (let [t (swap! !t inc)] (tap [:stamp]) t)))\r\n                              ->trace-id (fn [id v] (tap [:trace-id id v]) (str (name id) \"-1\"))]\r\n                      (with-listener (test-listener tap)\r\n                        (tap (trace :outer\r\n                               (trace :inner 0 1)))))\r\n                    (catch Pending _)\r\n                    (catch Cancelled _)\r\n                    (catch #?(:clj Throwable :cljs :default) e (prn :error (ex-message e)) (throw e))))\r\n    % := [:point-id :outer 0]\r\n    % := [:point {::point-id :outer, ::name :outer, ::parent ::root}]\r\n    % := [:point-id :inner :outer]\r\n    % := [:point {::point-id :inner, ::name :inner, ::parent :outer}]\r\n    % := [:trace-id :inner 1]\r\n    % := [:stamp]\r\n    % := [:trace :inner {::trace-id \"inner-1\", ::stamp 1, ::v 1, ::type ::ok}]\r\n    % := [:trace-id :outer 1]\r\n    % := [:stamp]\r\n    % := [:trace :outer {::trace-id \"outer-1\" ::stamp 2, ::v 1, ::type ::ok}]\r\n    % := 1))\r\n\r\n(defn monotonic [] (let [!t (atom 0)] (fn [_] (swap! !t inc))))\r\n\r\n(tests \"exceptions\"\r\n  (with (e/run (try (binding [->point-id (fn [nm _parent] nm), stamp (monotonic), ->trace-id (fn [id _v] (str (name id) \"-1\"))]\r\n                      (with-listener (test-listener tap)\r\n                        (tap (trace :x (throw (ex-info \"boom\" {}))))))\r\n                    (catch #?(:clj Throwable :cljs :default) e\r\n                      (when-not (= \"boom\" (ex-message e)) (prn [(type e) (ex-message e)])))))\r\n    % := [:point {::point-id :x, ::name :x, ::parent ::root}]\r\n    % := [:trace :x {::trace-id \"x-1\" , ::stamp 1, ::v _, ::type ::err}]))\r\n\r\n(tests \"works across e/fn boundaries\"\r\n  (with (e/run (try (binding [->point-id (fn [nm _parent] nm), stamp (monotonic), ->trace-id (fn [id _v] (str (name id) \"-1\"))]\r\n                      (with-listener (test-listener tap)\r\n                        (trace :outer\r\n                          (new (e/fn [] (trace :inner 1))))))\r\n                    (catch Pending _)\r\n                    (catch Cancelled _)\r\n                    (catch #?(:clj Throwable :cljs :default) e (prn :error (ex-message e)) (throw e))))\r\n    % := [:point _]\r\n    % := [:point _]\r\n    % := [:trace :inner {::trace-id \"inner-1\" ::stamp 1, ::v 1, ::type ::ok}]\r\n    % := [:trace :outer {::trace-id \"outer-1\", ::stamp 2, ::v 1, ::type ::ok}]))\r\n"]}