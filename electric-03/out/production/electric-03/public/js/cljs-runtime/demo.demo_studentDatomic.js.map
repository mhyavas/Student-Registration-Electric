{"version":3,"sources":["demo/demo_studentDatomic.cljc"],"mappings":";AAkDA,AACA,AACA,AAAKA,uCAAgB,6CAAA,2CAAA,wGAAA,kDAAA,0GAAA,KAAA,sGAAA,vcAACC;AAsBtB,AAMA,AAmBA,AA8CA,AAkBA,AAQA,AASA,AAOA,AAiBA,AAaA","names":["demo.demo-studentDatomic/!state","cljs.core.atom"],"sourcesContent":["(ns demo.demo-studentDatomic\r\n  \"Requires -Xss2m to compile. The Electric compiler exceeds the default 1m JVM ThreadStackSize\r\n  due to large macroexpansion resulting in false StackOverflowError during analysis.\"\r\n  (:require\r\n    contrib.str\r\n    #?(:clj [datomic.api :as d])\r\n    [hyperfiddle.electric :as e]\r\n    [hyperfiddle.electric-dom2 :as dom]\r\n    [hyperfiddle.electric-ui4 :as ui]\r\n    [missionary.core :as m]\r\n    ))\r\n\r\n;;; Datomic plumbing\r\n#?(:clj\r\n   (defn next-db< [conn]\r\n     (let [q (d/tx-report-queue conn)]\r\n       (m/observe (fn [!]\r\n                    (! (d/db conn))\r\n                    (let [t (Thread. ^Runnable\r\n                                     #(when (try (! (:db-after (.take ^java.util.concurrent.LinkedBlockingQueue q)))\r\n                                                 true\r\n                                                 (catch InterruptedException _))\r\n                                        (recur)))]\r\n                      (.start t)\r\n                      #(doto t .interrupt .join)))))))\r\n\r\n;; Datomic only allows a single queue consumer, so we need to spawn a singleton here\r\n;; In the next Electric iteration we can use `m/signal` and clean this up\r\n#?(:clj (defonce !db (atom nil)))\r\n#?(:clj (defonce !taker nil))\r\n#?(:clj (defn init-conn [schema]\r\n          (let [uri \"datomic:mem://todomvc\"]\r\n            (d/delete-database uri)\r\n            (d/create-database uri)\r\n            (let [conn (d/connect uri)]\r\n              (d/transact conn schema)\r\n              (when !taker (!taker))\r\n              (alter-var-root #'!taker (fn [_] ((m/reduce #(reset! !db %2) nil (next-db< conn)) identity identity)))\r\n              conn))))\r\n\r\n;; Application\r\n#?(:clj\r\n   (def schema\r\n     [{:db/ident :task/status,      :db/valueType :db.type/keyword, :db/cardinality :db.cardinality/one}\r\n      {:db/ident :task/description, :db/valueType :db.type/string,  :db/cardinality :db.cardinality/one}]))\r\n\r\n\r\n#?(:clj (defonce !conn (init-conn schema)))\r\n#?(:clj (comment (alter-var-root #'!conn (fn [_] (init-conn schema)))))\r\n\r\n(e/def db)                                                  ; server\r\n(e/def transact!) ; server\r\n(def !state #?(:cljs (atom {::filter :all                   ; client\r\n                            ::editing nil\r\n                            ::delay   0})))\r\n\r\n#?(:clj\r\n   (defn query-todos [db filter]\r\n     {:pre [filter]}\r\n     (case filter\r\n       :active (d/q '[:find [?e ...] :where [?e :task/status :active]] db)\r\n       :done   (d/q '[:find [?e ...] :where [?e :task/status :done]] db)\r\n       :all    (d/q '[:find [?e ...] :where [?e :task/status]] db))))\r\n\r\n#?(:clj\r\n   (defn todo-count [db filter]\r\n     {:pre  [filter]\r\n      :post [(number? %)]}\r\n     (-> (case filter\r\n           :active (d/q '[:find (count ?e) . :where [?e :task/status :active]] db)\r\n           :done   (d/q '[:find (count ?e) . :where [?e :task/status :done]] db)\r\n           :all    (d/q '[:find (count ?e) . :where [?e :task/status]] db))\r\n         (or 0)))) ; datascript can return nil wtf\r\n\r\n(e/defn Filter-control [state target label]\r\n        (dom/a (dom/props {:class (when (= state target) \"selected\")})\r\n               (dom/text label)\r\n               (dom/on \"click\" (e/fn [_] (swap! !state assoc ::filter target)))))\r\n\r\n\r\n(e/defn TodoStats [state]\r\n        (let [active (e/server (todo-count db :active))\r\n              done   (e/server (todo-count db :done))]\r\n          (dom/div\r\n            (dom/span (dom/props {:class \"todo-count\"})\r\n                      (dom/strong (dom/text active))\r\n                      (dom/span (dom/text \" \" (str (case active 1 \"item\" \"items\")) \" left\")))\r\n\r\n            (dom/ul (dom/props {:class \"filters\"})\r\n                    (dom/li (Filter-control. (::filter state) :all \"All\"))\r\n                    (dom/li (Filter-control. (::filter state) :active \"Active\"))\r\n                    (dom/li (Filter-control. (::filter state) :done \"Completed\")))\r\n\r\n            (when (pos? done)\r\n              (ui/button (e/fn [] (e/server (when-some [ids (seq (query-todos db :done))]\r\n                                              (transact! (mapv (fn [id] [:db/retractEntity id]) ids)) nil)))\r\n                         (dom/props {:class \"clear-completed\"})\r\n                         (dom/text \"Clear completed \" done))))))\r\n\r\n(e/defn TodoItem [state id]\r\n        (e/server\r\n          ;; we'd use `d/entity` is not for this Datomic bug\r\n          ;; https://ask.datomic.com/index.php/859/equality-on-d-entity-ignores-db?show=859#q859\r\n          (let [{:keys [:task/status :task/description]} (d/pull db '[:task/status :task/description] id)]\r\n            (e/client\r\n              (let [uuid (random-uuid)]\r\n                (dom/li\r\n                  (dom/props {:class [(when (= :done status) \"completed\")\r\n                                      (when (= uuid (::editing state)) \"editing\")]})\r\n                  (dom/div (dom/props {:class \"view\"})\r\n                           (ui/checkbox (= :done status) (e/fn [v]\r\n                                                               (let [status (case v true :done, false :active, nil)]\r\n                                                                 (e/server (transact! [{:db/id id, :task/status status}]) nil)))\r\n                                        (dom/props {:class \"toggle\"}))\r\n                           (dom/label (dom/text description)\r\n                                      (dom/on \"dblclick\" (e/fn [_] (swap! !state assoc ::editing uuid)))))\r\n                  (when (= uuid (::editing state))\r\n                    (dom/span (dom/props {:class \"input-load-mask\"})\r\n                              (dom/on-pending (dom/props {:aria-busy true})\r\n                                              (dom/input\r\n                                                (dom/on \"keydown\"\r\n                                                        (e/fn [e]\r\n                                                              (case (.-key e)\r\n                                                                \"Enter\" (when-some [description (contrib.str/blank->nil (-> e .-target .-value))]\r\n                                                                          (case (e/server (transact! [{:db/id id, :task/description description}]) nil)\r\n                                                                            (swap! !state assoc ::editing nil)))\r\n                                                                \"Escape\" (swap! !state assoc ::editing nil)\r\n                                                                nil)))\r\n                                                (dom/on \"blur\"\r\n                                                        (e/fn [e]\r\n                                                              (when-some [description (contrib.str/blank->nil (-> e .-target .-value))]\r\n                                                                (case (e/server (transact! [{:db/id id, :task/description description}]) nil)\r\n                                                                  (swap! !state assoc ::editing nil)))))\r\n                                                (dom/props {:class \"edit\" #_#_:autofocus true})\r\n                                                (dom/bind-value description) ; first set the initial value, then focus\r\n                                                (case description ; HACK sequence - run focus after description is available\r\n                                                  (.focus dom/node))))))\r\n                  (ui/button (e/fn [] (e/server (transact! [[:db/retractEntity id]]) nil))\r\n                             (dom/props {:class \"destroy\"}))))))))\r\n\r\n#?(:clj\r\n   (defn toggle-all! [db status]\r\n     (let [ids    (query-todos db (if (= :done status) :active :done))]\r\n       (map (fn [id] {:db/id id, :task/status status}) ids))))\r\n\r\n(e/defn TodoList [state]\r\n        (e/client\r\n          (dom/div\r\n            (dom/section (dom/props {:class \"main\"})\r\n                         (let [active (e/server (todo-count db :active))\r\n                               all    (e/server (todo-count db :all))\r\n                               done   (e/server (todo-count db :done))]\r\n                           (ui/checkbox (cond (= all done)   true\r\n                                              (= all active) false\r\n                                              :else          nil)\r\n                                        (e/fn [v] (let [status (case v (true nil) :done, false :active)]\r\n                                                    (e/server (transact! (toggle-all! db status)) nil)))\r\n                                        (dom/props {:class \"toggle-all\"})))\r\n                         (dom/label (dom/props {:for \"toggle-all\"}) (dom/text \"Mark all as complete\"))\r\n                         (dom/ul (dom/props {:class \"todo-list\"})\r\n                                 (e/for [id (e/server (sort (query-todos db (::filter state))))]\r\n                                        (TodoItem. state id)))))))\r\n\r\n(e/defn CreateTodo []\r\n        (dom/span (dom/props {:class \"input-load-mask\"})\r\n                  (dom/on-pending (dom/props {:aria-busy true})\r\n                                  (dom/input\r\n                                    (ui/on-submit (e/fn [description]\r\n                                                        (e/server (transact! [{:task/description description, :task/status :active}]) nil)))\r\n                                    (dom/props {:class \"new-todo\", :placeholder \"What needs to be done?\"})))))\r\n\r\n(e/defn TodoMVC-UI [state]\r\n        (dom/section (dom/props {:class \"todoapp\"})\r\n                     (dom/header (dom/props {:class \"header\"})\r\n                                 (CreateTodo.))\r\n                     (when (e/server (pos? (todo-count db :all)))\r\n                       (TodoList. state))\r\n                     (dom/footer (dom/props {:class \"footer\"})\r\n                                 (TodoStats. state))))\r\n\r\n(e/defn TodoMVC-body [state]\r\n        (dom/div (dom/props {:class \"todomvc\"})\r\n                 (dom/h1 (dom/text \"TodoMVC\"))\r\n                 (TodoMVC-UI. state)\r\n                 (dom/footer (dom/props {:class \"info\"})\r\n                             (dom/p (dom/text \"Double-click to edit a todo\")))))\r\n\r\n(e/defn Diagnostics [state]\r\n        (dom/h1 (dom/text \"Diagnostics\"))\r\n        (dom/dl\r\n          (dom/dt (dom/text \"count :all\")) (dom/dd (dom/text (pr-str (e/server (todo-count db :all)))))\r\n          (dom/dt (dom/text \"query :all\")) (dom/dd (dom/text (pr-str (e/server (query-todos db :all)))))\r\n          (dom/dt (dom/text \"state\")) (dom/dd (dom/text (pr-str state)))\r\n          (dom/dt (dom/text \"delay\")) (dom/dd\r\n                                        (ui/long (::delay state) (e/fn [v] (swap! !state assoc ::delay v))\r\n                                                 (dom/props {:step 1, :min 0, :style {:width :min-content}}))\r\n                                        (dom/text \" ms\"))))\r\n\r\n#?(:clj\r\n   (defn slow-transact! [!conn delay tx]\r\n     (try (Thread/sleep delay) ; artificial latency\r\n          (d/transact !conn tx)\r\n          (catch InterruptedException _))))\r\n\r\n(e/defn TodoMVC []\r\n        (e/client\r\n          (let [state (e/watch !state)]\r\n            (e/server\r\n              (binding [db (e/watch !db)\r\n                        transact! (partial slow-transact! !conn (e/client (::delay state)))]\r\n                (e/client\r\n                  (dom/link (dom/props {:rel :stylesheet, :href \"/todomvc.css\"}))\r\n                  ; exclude #root style from todomvc-composed by inlining here\r\n                  (dom/element \"style\" (dom/text \"body.hyperfiddle { width: 65vw; margin-left: auto; margin-right: auto; }\"))\r\n                  (TodoMVC-body. state)\r\n                  #_(Diagnostics. state)))))))\r\n\r\n(comment\r\n  (todo-count @!conn :all)\r\n  (todo-count @!conn :active)\r\n  (todo-count @!conn :done)\r\n  (query-todos @!conn :all)\r\n  (query-todos @!conn :active)\r\n  (query-todos @!conn :done)\r\n  (d/q '[:find (count ?e) . :where [?e :task/status]] @!conn)\r\n  )\r\n"]}