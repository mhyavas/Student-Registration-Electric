shadow$provide.module$node_modules$react_offcanvas$node_modules$react$lib$ReactMount=function(global,require,module,exports){function getReactRootElementInContainer(container){return container?9===container.nodeType?container.documentElement:container.firstChild:null}function getReactRootID(container){return(container=getReactRootElementInContainer(container))&&ReactMount.getID(container)}function internalGetID(node){return node&&node.getAttribute&&node.getAttribute(ATTR_NAME)||""}function isValid(node,
id){return node&&(internalGetID(node)!==id?invariant(!1,"ReactMount: Unexpected modification of `%s`",ATTR_NAME):void 0,(id=ReactMount.findReactContainerForID(id))&&containsNode(id,node))?!0:!1}function findDeepestCachedAncestorImpl(ancestorID){var ancestor=nodeCache[ancestorID];if(ancestor&&isValid(ancestor,ancestorID))deepestNodeSoFar=ancestor;else return!1}function mountComponentIntoNode(componentInstance,rootID,container,transaction,shouldReuseMarkup,context){ReactDOMFeatureFlags.useCreateElement&&
(context=assign({},context),context[ownerDocumentContextKey]=9===container.nodeType?container:container.ownerDocument);context===emptyObject&&(context={});var tag=container.nodeName.toLowerCase();context[validateDOMNesting.ancestorInfoContextKey]=validateDOMNesting.updatedAncestorInfo(null,tag,null);rootID=ReactReconciler.mountComponent(componentInstance,rootID,transaction,context);componentInstance._renderedComponent._topLevelWrapper=componentInstance;ReactMount._mountImageIntoNode(rootID,container,
shouldReuseMarkup,transaction)}function batchedMountComponentIntoNode(componentInstance,rootID,container,shouldReuseMarkup,context){var transaction=ReactUpdates.ReactReconcileTransaction.getPooled(shouldReuseMarkup);transaction.perform(mountComponentIntoNode,null,componentInstance,rootID,container,transaction,shouldReuseMarkup,context);ReactUpdates.ReactReconcileTransaction.release(transaction)}function unmountComponentFromNode(instance,container){ReactReconciler.unmountComponent(instance);9===container.nodeType&&
(container=container.documentElement);for(;container.lastChild;)container.removeChild(container.lastChild)}function hasNonRootReactChild(node){return(node=getReactRootID(node))?node!==ReactInstanceHandles.getReactRootIDFromNodeID(node):!1}function findFirstReactDOMImpl(node){for(;node&&node.parentNode!==node;node=node.parentNode)if(1===node.nodeType){var nodeID=internalGetID(node);if(nodeID){nodeID=ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);var current=node;do{var lastID=internalGetID(current);
current=current.parentNode;if(null==current)return null}while(lastID!==nodeID);if(current===containersByReactRootID[nodeID])return node}}return null}global=require("module$node_modules$react_offcanvas$node_modules$react$lib$DOMProperty");var ReactBrowserEventEmitter=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactBrowserEventEmitter"),ReactCurrentOwner=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactCurrentOwner"),ReactDOMFeatureFlags=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactDOMFeatureFlags"),
ReactElement=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactElement"),ReactEmptyComponentRegistry=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactEmptyComponentRegistry"),ReactInstanceHandles=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactInstanceHandles"),ReactInstanceMap=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactInstanceMap"),ReactMarkupChecksum=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactMarkupChecksum");
exports=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactPerf");var ReactReconciler=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactReconciler"),ReactUpdateQueue=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactUpdateQueue"),ReactUpdates=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactUpdates"),assign=require("module$node_modules$react_offcanvas$node_modules$react$lib$Object_assign"),emptyObject=require("module$node_modules$fbjs$lib$emptyObject"),
containsNode=require("module$node_modules$fbjs$lib$containsNode"),instantiateReactComponent=require("module$node_modules$react_offcanvas$node_modules$react$lib$instantiateReactComponent"),invariant=require("module$node_modules$fbjs$lib$invariant"),setInnerHTML=require("module$node_modules$react_offcanvas$node_modules$react$lib$setInnerHTML"),shouldUpdateReactComponent=require("module$node_modules$react_offcanvas$node_modules$react$lib$shouldUpdateReactComponent"),validateDOMNesting=require("module$node_modules$react_offcanvas$node_modules$react$lib$validateDOMNesting"),
warning=require("module$node_modules$fbjs$lib$warning"),ATTR_NAME=global.ID_ATTRIBUTE_NAME,nodeCache={},ownerDocumentContextKey="__ReactMount_ownerDocument$"+Math.random().toString(36).slice(2),instancesByReactRootID={},containersByReactRootID={},rootElementsByReactRootID={},findComponentRootReusableArray=[],deepestNodeSoFar=null,TopLevelWrapper=function(){};TopLevelWrapper.prototype.isReactComponent={};TopLevelWrapper.displayName="TopLevelWrapper";TopLevelWrapper.prototype.render=function(){return this.props};
var ReactMount={TopLevelWrapper,_instancesByReactRootID:instancesByReactRootID,scrollMonitor:function(container,renderCallback){renderCallback()},_updateRootComponent:function(prevComponent,nextElement,container,callback){ReactMount.scrollMonitor(container,function(){ReactUpdateQueue.enqueueElementInternal(prevComponent,nextElement);callback&&ReactUpdateQueue.enqueueCallbackInternal(prevComponent,callback)});rootElementsByReactRootID[getReactRootID(container)]=getReactRootElementInContainer(container);
return prevComponent},_registerComponent:function(nextComponent,container){!container||1!==container.nodeType&&9!==container.nodeType&&11!==container.nodeType?invariant(!1,"_registerComponent(...): Target container is not a DOM element."):void 0;ReactBrowserEventEmitter.ensureScrollValueMonitoring();container=ReactMount.registerContainer(container);instancesByReactRootID[container]=nextComponent;return container},_renderNewRootComponent:function(nextElement,container,shouldReuseMarkup,context){warning(null==
ReactCurrentOwner.current,"_renderNewRootComponent(): Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate. Check the render method of %s.",ReactCurrentOwner.current&&ReactCurrentOwner.current.getName()||"ReactCompositeComponent");nextElement=instantiateReactComponent(nextElement,null);var reactRootID=ReactMount._registerComponent(nextElement,container);ReactUpdates.batchedUpdates(batchedMountComponentIntoNode,
nextElement,reactRootID,container,shouldReuseMarkup,context);rootElementsByReactRootID[reactRootID]=getReactRootElementInContainer(container);return nextElement},renderSubtreeIntoContainer:function(parentComponent,nextElement,container,callback){null==parentComponent||null==parentComponent._reactInternalInstance?invariant(!1,"parentComponent must be a valid React Component"):void 0;return ReactMount._renderSubtreeIntoContainer(parentComponent,nextElement,container,callback)},_renderSubtreeIntoContainer:function(parentComponent,
nextElement,container,callback){ReactElement.isValidElement(nextElement)?void 0:invariant(!1,"ReactDOM.render(): Invalid component element.%s","string"===typeof nextElement?" Instead of passing an element string, make sure to instantiate it by passing it to React.createElement.":"function"===typeof nextElement?" Instead of passing a component class, make sure to instantiate it by passing it to React.createElement.":null!=nextElement&&void 0!==nextElement.props?" This may be caused by unintentionally loading two independent copies of React.":
"");warning(!container||!container.tagName||"BODY"!==container.tagName.toUpperCase(),"render(): Rendering components directly into document.body is discouraged, since its children are often manipulated by third-party scripts and browser extensions. This may lead to subtle reconciliation issues. Try rendering into a container element created for your app.");var nextWrappedElement=new ReactElement(TopLevelWrapper,null,null,null,null,null,nextElement),prevComponent=instancesByReactRootID[getReactRootID(container)];
if(prevComponent){if(shouldUpdateReactComponent(prevComponent._currentElement.props,nextElement)){var publicInst=prevComponent._renderedComponent.getPublicInstance();ReactMount._updateRootComponent(prevComponent,nextWrappedElement,container,callback&&function(){callback.call(publicInst)});return publicInst}ReactMount.unmountComponentAtNode(container)}var reactRootElement=getReactRootElementInContainer(container);nextElement=reactRootElement&&!!internalGetID(reactRootElement);var containerHasNonRootReactChild=
hasNonRootReactChild(container);warning(!containerHasNonRootReactChild,"render(...): Replacing React-rendered children with a new root component. If you intended to update the children of this node, you should instead have the existing children update their state and render the new components instead of calling ReactDOM.render.");if(!nextElement||reactRootElement.nextSibling)for(;reactRootElement;){if(internalGetID(reactRootElement)){warning(!1,"render(): Target node has markup rendered by React, but there are unrelated nodes as well. This is most commonly caused by white-space inserted around server-rendered markup.");
break}reactRootElement=reactRootElement.nextSibling}parentComponent=ReactMount._renderNewRootComponent(nextWrappedElement,container,nextElement&&!prevComponent&&!containerHasNonRootReactChild,null!=parentComponent?parentComponent._reactInternalInstance._processChildContext(parentComponent._reactInternalInstance._context):emptyObject)._renderedComponent.getPublicInstance();callback&&callback.call(parentComponent);return parentComponent},render:function(nextElement,container,callback){return ReactMount._renderSubtreeIntoContainer(null,
nextElement,container,callback)},registerContainer:function(container){var reactRootID=getReactRootID(container);reactRootID&&(reactRootID=ReactInstanceHandles.getReactRootIDFromNodeID(reactRootID));reactRootID||(reactRootID=ReactInstanceHandles.createReactRootID());containersByReactRootID[reactRootID]=container;return reactRootID},unmountComponentAtNode:function(container){warning(null==ReactCurrentOwner.current,"unmountComponentAtNode(): Render methods should be a pure function of props and state; triggering nested component updates from render is not allowed. If necessary, trigger nested updates in componentDidUpdate. Check the render method of %s.",
ReactCurrentOwner.current&&ReactCurrentOwner.current.getName()||"ReactCompositeComponent");!container||1!==container.nodeType&&9!==container.nodeType&&11!==container.nodeType?invariant(!1,"unmountComponentAtNode(...): Target container is not a DOM element."):void 0;var reactRootID=getReactRootID(container),component=instancesByReactRootID[reactRootID];if(!component)return reactRootID=hasNonRootReactChild(container),container=(container=internalGetID(container))&&container===ReactInstanceHandles.getReactRootIDFromNodeID(container),
warning(!reactRootID,"unmountComponentAtNode(): The node you're attempting to unmount was rendered by React and is not a top-level container. %s",container?"You may have accidentally passed in a React root node instead of its container.":"Instead, have the parent component update its state and rerender in order to remove this component."),!1;ReactUpdates.batchedUpdates(unmountComponentFromNode,component,container);delete instancesByReactRootID[reactRootID];delete containersByReactRootID[reactRootID];
delete rootElementsByReactRootID[reactRootID];return!0},findReactContainerForID:function(id){id=ReactInstanceHandles.getReactRootIDFromNodeID(id);var container=containersByReactRootID[id],rootElement=rootElementsByReactRootID[id];if(rootElement&&rootElement.parentNode!==container){warning(internalGetID(rootElement)===id,"ReactMount: Root element ID differed from reactRootID.");var containerChild=container.firstChild;containerChild&&id===internalGetID(containerChild)?rootElementsByReactRootID[id]=
containerChild:warning(!1,"ReactMount: Root element has been removed from its original container. New container: %s",rootElement.parentNode)}return container},findReactNodeByID:function(id){var reactRoot=ReactMount.findReactContainerForID(id);return ReactMount.findComponentRoot(reactRoot,id)},getFirstReactDOM:function(node){return findFirstReactDOMImpl(node)},findComponentRoot:function(ancestorNode,targetID){var childIndex=0;deepestNodeSoFar=null;ReactInstanceHandles.traverseAncestors(targetID,findDeepestCachedAncestorImpl);
var foundNode=deepestNodeSoFar;deepestNodeSoFar=null;foundNode=foundNode||ancestorNode;warning(null!=foundNode,"React can't find the root component node for data-reactid value `%s`. If you're seeing this message, it probably means that you've loaded two copies of React on the page. At this time, only a single copy of React can be loaded at a time.",targetID);findComponentRootReusableArray[0]=foundNode.firstChild;for(findComponentRootReusableArray.length=1;childIndex<findComponentRootReusableArray.length;){foundNode=
findComponentRootReusableArray[childIndex++];for(var targetChild;foundNode;){var childID=ReactMount.getID(foundNode);childID?targetID===childID?targetChild=foundNode:ReactInstanceHandles.isAncestorIDOf(childID,targetID)&&(findComponentRootReusableArray.length=childIndex=0,findComponentRootReusableArray.push(foundNode.firstChild)):findComponentRootReusableArray.push(foundNode.firstChild);foundNode=foundNode.nextSibling}if(targetChild)return findComponentRootReusableArray.length=0,targetChild}findComponentRootReusableArray.length=
0;invariant(!1,"findComponentRoot(..., %s): Unable to find element. This probably means the DOM was unexpectedly mutated (e.g., by the browser), usually due to forgetting a \x3ctbody\x3e when using tables, nesting tags like \x3cform\x3e, \x3cp\x3e, or \x3ca\x3e, or using non-SVG elements in an \x3csvg\x3e parent. Try inspecting the child nodes of the element with React ID `%s`.",targetID,ReactMount.getID(ancestorNode))},_mountImageIntoNode:function(markup,container,shouldReuseMarkup,transaction){!container||
1!==container.nodeType&&9!==container.nodeType&&11!==container.nodeType?invariant(!1,"mountComponentIntoNode(...): Target container is not valid."):void 0;if(shouldReuseMarkup){var rootElement=getReactRootElementInContainer(container);if(ReactMarkupChecksum.canReuseMarkup(markup,rootElement))return;var checksum=rootElement.getAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);rootElement.removeAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME);shouldReuseMarkup=rootElement.outerHTML;rootElement.setAttribute(ReactMarkupChecksum.CHECKSUM_ATTR_NAME,
checksum);1===container.nodeType?(checksum=document.createElement("div"),checksum.innerHTML=markup,rootElement=checksum.innerHTML):(checksum=document.createElement("iframe"),document.body.appendChild(checksum),checksum.contentDocument.write(markup),rootElement=checksum.contentDocument.documentElement.outerHTML,document.body.removeChild(checksum));a:{checksum=rootElement;for(var minLen=Math.min(checksum.length,shouldReuseMarkup.length),i=0;i<minLen;i++)if(checksum.charAt(i)!==shouldReuseMarkup.charAt(i)){checksum=
i;break a}checksum=checksum.length===shouldReuseMarkup.length?-1:minLen}shouldReuseMarkup=" (client) "+rootElement.substring(checksum-20,checksum+20)+"\n (server) "+shouldReuseMarkup.substring(checksum-20,checksum+20);9===container.nodeType?invariant(!1,"You're trying to render a component to the document using server rendering but the checksum was invalid. This usually means you rendered a different component type or props on the client from the one on the server, or your render() methods are impure. React cannot handle this case due to cross-browser quirks by rendering at the document root. You should look for environment dependent code in your components and ensure the props are the same client and server side:\n%s",
shouldReuseMarkup):void 0;warning(!1,"React attempted to reuse markup in a container but the checksum was invalid. This generally means that you are using server rendering and the markup generated on the server was not what the client was expecting. React injected new markup to compensate which works but you have lost many of the benefits of server rendering. Instead, figure out why the markup being generated is different on the client or server:\n%s",shouldReuseMarkup)}9===container.nodeType?invariant(!1,
"You're trying to render a component to the document but you didn't use server rendering. We can't do this without using server rendering due to cross-browser quirks. See ReactDOMServer.renderToString() for server rendering."):void 0;if(transaction.useCreateElement){for(;container.lastChild;)container.removeChild(container.lastChild);container.appendChild(markup)}else setInnerHTML(container,markup)},ownerDocumentContextKey,getReactRootID,getID:function(node){var id=internalGetID(node);if(id)if(nodeCache.hasOwnProperty(id)){var cached=
nodeCache[id];cached!==node&&(isValid(cached,id)?invariant(!1,"ReactMount: Two valid but unequal nodes with the same `%s`: %s",ATTR_NAME,id):void 0,nodeCache[id]=node)}else nodeCache[id]=node;return id},setID:function(node,id){var oldID=internalGetID(node);oldID!==id&&delete nodeCache[oldID];node.setAttribute(ATTR_NAME,id);nodeCache[id]=node},getNode:function(id){nodeCache.hasOwnProperty(id)&&isValid(nodeCache[id],id)||(nodeCache[id]=ReactMount.findReactNodeByID(id));return nodeCache[id]},getNodeFromInstance:function(instance){instance=
ReactInstanceMap.get(instance)._rootNodeID;if(ReactEmptyComponentRegistry.isNullComponentID(instance))return null;nodeCache.hasOwnProperty(instance)&&isValid(nodeCache[instance],instance)||(nodeCache[instance]=ReactMount.findReactNodeByID(instance));return nodeCache[instance]},isValid,purgeID:function(id){delete nodeCache[id]}};exports.measureMethods(ReactMount,"ReactMount",{_renderNewRootComponent:"_renderNewRootComponent",_mountImageIntoNode:"_mountImageIntoNode"});module.exports=ReactMount}
//# sourceMappingURL=module$node_modules$react_offcanvas$node_modules$react$lib$ReactMount.js.map
