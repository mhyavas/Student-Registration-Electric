{"version":3,"sources":["contrib/datomic_cloud_contrib.cljs"],"mappings":";;;;AAQA,AAwBA,AAiBA,AAAA,CAAA,AAAA,iGAAAA,jGAAaC;;AAAb,CAAA,AAAA,AAAaA,mHAEX,WAA6BC,EAAEC,OAAOC;AAAtC,AAAA,YAAA,RAA6BF;AAA7B,AAAyC,OAACG,iBAAOF,OAAO,CAAA,mFAAA,lBAA0B,AAAWD;;AAE/F,AAuBA,AAgBA","names":["cljs.core/PROTOCOL_SENTINEL","contrib.datomic_cloud_contrib.goog$module$goog$math$Long","o","writer","_","cljs.core/-write"],"sourcesContent":["(ns contrib.datomic-cloud-contrib\n  (:require clojure.edn\n            [hyperfiddle.rcf :refer [tests]])\n  (:import [goog.math Long]))\n\n; Issue: Datomic Cloud db/ids (java.lang.Longs) can exceed the maximum integer representable in\n; javascript's Number type which is a double:\n\n(tests\n  \"javascript platform number type rounds large longs when they exceed what double precision\n  can represent exactly\"\n  (def js-max-int 9007199254740991)\n  (= js-max-int (+ 1 js-max-int)) := false ; correct\n  (= (+ 1 js-max-int) (+ 2 js-max-int)) := true ; yikes!\n  (= 9007199254740992 9007199254740993) := true ; yikes!\n\n  (->> [9007199254740989\n        9007199254740990\n        9007199254740991\n        9007199254740992\n        9007199254740993\n        9007199254740994\n        9007199254740995\n        9007199254740996]\n       (map (partial = 9007199254740992)))\n  := [false false false\n      true true ; yikes!\n      false false false])\n\n; transit-js works around this by reading too-large numbers as goog.math.Long:\n; https://github.com/cognitect/transit-js/blob/9c28b4d9afaddae3cf15073296fcd736f68600a9/src/com/cognitect/transit/types.js#L82-L99\n\n(tests\n  \"Transit-js workaround is to use object longs instead\"\n  (def xs (map goog.math.Long/fromString\n               [\"9007199254740989\"\n                \"9007199254740990\"\n                \"9007199254740991\"\n                \"9007199254740992\"\n                \"9007199254740993\"\n                \"9007199254740994\"\n                \"9007199254740995\"\n                \"9007199254740996\"]))\n  (map (partial = 9007199254740992) xs)\n  := [false false false false false false false false])\n\n; EDN serializers must encode the value as strings, because by the time the cljs reader sees a\n; value, it has already been ready by javascript and damaged.\n\n(extend-type goog.math.Long\n  IPrintWithWriter\n  (-pr-writer [^goog.math.Long o writer _] (-write writer (str \"#goog.math/Long \\\"\" (.toString o) \"\\\"\"))))\n\n(tests\n  \"edn writer\"\n  (def too-big (goog.math.Long/fromString \"9007199254740992\"))\n  (pr-str too-big) := \"#goog.math/Long \\\"9007199254740992\\\"\"\n\n  (->> [\"9007199254740989\"\n        \"9007199254740990\"\n        \"9007199254740991\"\n        \"9007199254740992\"\n        \"9007199254740993\"\n        \"9007199254740994\"\n        \"9007199254740995\"\n        \"9007199254740996\"]\n       (map (comp pr-str goog.math.Long/fromString)))\n  := [\"#goog.math/Long \\\"9007199254740989\\\"\"\n      \"#goog.math/Long \\\"9007199254740990\\\"\"\n      \"#goog.math/Long \\\"9007199254740991\\\"\"\n      \"#goog.math/Long \\\"9007199254740992\\\"\"\n      \"#goog.math/Long \\\"9007199254740993\\\"\"\n      \"#goog.math/Long \\\"9007199254740994\\\"\"\n      \"#goog.math/Long \\\"9007199254740995\\\"\"\n      \"#goog.math/Long \\\"9007199254740996\\\"\"])\n\n(tests\n  (cljs.reader/read-string \"#goog.math/Long \\\"9007199254740996\\\"\")\n  :throws js/Error ; No reader function for tag long.\n\n  (def x (cljs.reader/read-string {:readers {'goog.math/Long goog.math.Long/fromString}} \"#goog.math/Long \\\"9007199254740996\\\"\"))\n  x := (goog.math.Long/fromString \"9007199254740996\")\n\n  ; x := #goog.math/Long\"9007199254740996\" -- compiler error\n  ; this is runtime only! Is there a business case for hardcoding large literals like that?\n\n  \"you can inject something like this over a region (to avoid global state)\"\n  ; yes we know bindings are pretty busted in clojure, but it beats mutable global state\n  (def ^:dynamic *read-str* nil)\n  (binding [*read-str* (partial cljs.reader/read-string {:readers {'goog.math/Long goog.math.Long/fromString}})]\n    (*read-str* \"#goog.math/Long \\\"9007199254740996\\\"\")) := x)\n\n(tests\n  \"edn reader\"\n  (cljs.reader/read-string \"#goog.math/Long \\\"9007199254740996\\\"\")\n  :throws js/Error ; No reader function for tag long.\n\n  (clojure.edn/read-string {:readers {'goog.math/Long goog.math.Long/fromString}} \"#goog.math/Long \\\"9007199254740996\\\"\")\n  := x\n\n  (def ^:dynamic *read-str* nil)\n  (binding [*read-str* (partial clojure.edn/read-string {:readers {'goog.math/Long goog.math.Long/fromString}})]\n    (*read-str* \"#goog.math/Long \\\"9007199254740996\\\"\")) := x)\n\n; For the Clojure reader case, I think we don't need to support large compile-time literal longs,\n; this is a runtime concern only and thus we only implement the EDN readers in clojurescript.\n"],"x_google_ignoreList":[0]}