{"version":3,"sources":["contrib/char$.cljc"],"mappings":";AAKA,2BAAA,3BAAMA,8DAAYC;AAAlB,AACW,iCAAIA,1BAAEC;;AAGjB,2BAAA,3BAAMC,8DAAYF;AAAlB,AACW,iCAAIA,1BAAEG;;AAGjB,AAQA,0BAAA,1BAAME,4DAAWL;AAAjB,AAAA,oBACSA;AADT;AAAA,AAAA,MAAA,KAAAI,MAAA;;;AAOW,OAAaJ;;AAGxB,AAEA,4BAAA,wCAAA,IAAA,IAAA,IAAA,IAAA,KAAA,KAAA,IAAA,IAAA,KAAA,IAAA,KAAA,IAAA,IAAA,KAAA,KAAA,MAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,IAAA,xMAAKM;AACL,AAAKC,4BAAS,AAACC,uGAAM,AAACC,uBAAWH,2BACZ,AAACG,uBAAyB,AAACC,oBAAU,WAAKC,EAAEC,EAAEC;AAAT,AAAY,OAACC,8CAAMH,EAAEC,EAAE,AAACV,yBAAWW;sCAAvDP,nCAAS;AAE/C,AAIA,iCAAA,jCAAMS,0EAAef;AAArB,AAAA,oBACSA;AADT;AAAA,AAAA,MAAA,KAAAI,MAAA;;;AAIE,+HACK,AAAC,6CAAA,WAAAY,xDAACE,tEACF,AAACG,4CAAIf,9FACLgB;AAFC,AAAO,sBAAAN,iBAAA,hCAACG;GAAR,WAAAF;AAAA,AAAoB,qBAAAA,iBAAA,/BAACG;IADtB,AAACf,wBAAUL;;AAKlB,iCAAA,jCAAMuB,0EAAeC;AAArB,AAAA,GACS,6CAAA,7CAACC,iDAAI,AAACC,gBAAMF;AADrB;AAAA,AAAA,MAAA,KAAApB,MAAA;;;AAEE,IAAAuB,aAAY,AAACN,4CAAId,0BAASiB;QAA1B,AAAAI,4CAAAD,WAAA,IAAA,/DAAOE;QAAP,AAAAD,4CAAAD,WAAA,IAAA,/DAASG;AAAT,AACE,OAACC,gBAAK,CAAG,CAAA,OAAM,KAAA,JAAKF,YAAI,KAAA,JAAKC;;AAEjC","names":["contrib.char$/char-upper","c","clojure.string/upper-case","contrib.char$/char-lower","clojure.string/lower-case","js/Error","contrib.char$/char-code","contrib.char$/dec->hex","contrib.char$/hex->dec","cljs.core.merge","clojure.set/map-invert","cljs.core/reduce-kv","m","k","v","cljs.core.assoc","contrib.char$/char->hex-str","p1__32323#","p1__32324#","cljs.core.juxt","cljs.core/quot","cljs.core/mod","cljs.core.map","clojure.string.join","contrib.char$/hex-str->char","s","cljs.core._EQ_","cljs.core/count","vec__32328","cljs.core.nth","a","b","cljs.core/char"],"sourcesContent":["(ns contrib.char$\n  (:require [clojure.set :refer [map-invert]]\n            [clojure.string :as string]\n            [hyperfiddle.rcf :refer [tests]]))\n\n(defn char-upper [c]\n  #?(:cljs (-> c string/upper-case)\n     :clj  (-> c string/upper-case first)))\n\n(defn char-lower [c]\n  #?(:cljs (-> c string/lower-case)\n     :clj  (-> c string/lower-case first)))\n\n(tests\n  (char-upper \\c) := \\C ; portable?\n  (char-lower \\C) := \\c\n\n  \"works on strings\"\n  (char-upper \"c\") := \\C ; portable?\n  (char-lower \"C\") := \\c)\n\n(defn char-code [c]\n  {:pre [c]}\n  ; cljs.user=> (map identity \"abcd\") => (\"a\" \"b\" \"c\" \"d\")\n  ; cljs.user=> (map #(.charCodeAt %) \"abcd\") => (97 98 99 100)\n  ;\n  ; user=> (map identity \"abcd\") => (\\a \\b \\c \\d)\n  ; user=> (map int \"abcd\") => (97 98 99 100)\n  #?(:cljs (.charCodeAt c)\n     :clj  (int c)))\n\n(tests (map char-code \"abcd|\") := [97 98 99 100 124])\n\n(def dec->hex {0 \\0 1 \\1 2 \\2 3 \\3 4 \\4 5 \\5 6 \\6 7 \\7 8 \\8 9 \\9 10 \\A 11 \\B 12 \\C 13 \\D 14 \\E 15 \\F})\n(def hex->dec (merge (map-invert dec->hex)\n                     (map-invert (->> dec->hex (reduce-kv (fn [m k v] (assoc m k (char-lower v))) {})))))\n\n(tests\n  (dec->hex 10) := \\A\n  (hex->dec \\A) := 10)\n\n(defn char->hex-str [c]\n  {:pre [c]}\n  ; Portable - the usual primitives are platform specific and weird interfaces\n  ;{:pre [(< n 256) (> n 0)]}\n  (->> (char-code c)\n       ((juxt #(quot % 16) #(mod % 16)))\n       (map dec->hex)\n       string/join))\n\n(defn hex-str->char [s]\n  {:pre [(= 2 (count s))]}\n  (let [[a b] (map hex->dec s)]\n    (char (+ (* 16 (int a)) (int b)))))\n\n(tests\n  (hex->dec \\a) := (hex->dec \\A)\n  (char->hex-str \\space) := \"20\"\n  (char->hex-str \\newline) := \"0A\"\n  (not= (char->hex-str \\newline) \"0a\") := true\n  ((comp hex-str->char char->hex-str) \\space) := \\space\n  ((comp hex-str->char char->hex-str) \\newline) := \\newline\n  ((comp hex-str->char char->hex-str) \\a) := \\a)"]}