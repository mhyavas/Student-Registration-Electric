{
"version":3,
"file":"module$node_modules$react_offcanvas$node_modules$react$lib$EventPluginRegistry.js",
"lineCount":9,
"mappings":"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",
"sources":["node_modules/react-offcanvas/node_modules/react/lib/EventPluginRegistry.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$react_offcanvas$node_modules$react$lib$EventPluginRegistry\"] = function(global,require,module,exports) {\n/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPluginRegistry\n * @typechecks static-only\n */\n\n'use strict';\n\nvar invariant = require('fbjs/lib/invariant');\n\n/**\n * Injectable ordering of event plugins.\n */\nvar EventPluginOrder = null;\n\n/**\n * Injectable mapping from names to event plugin modules.\n */\nvar namesToPlugins = {};\n\n/**\n * Recomputes the plugin list using the injected plugins and plugin ordering.\n *\n * @private\n */\nfunction recomputePluginOrdering() {\n  if (!EventPluginOrder) {\n    // Wait until an `EventPluginOrder` is injected.\n    return;\n  }\n  for (var pluginName in namesToPlugins) {\n    var PluginModule = namesToPlugins[pluginName];\n    var pluginIndex = EventPluginOrder.indexOf(pluginName);\n    !(pluginIndex > -1) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugins that do not exist in ' + 'the plugin ordering, `%s`.', pluginName) : invariant(false) : undefined;\n    if (EventPluginRegistry.plugins[pluginIndex]) {\n      continue;\n    }\n    !PluginModule.extractEvents ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Event plugins must implement an `extractEvents` ' + 'method, but `%s` does not.', pluginName) : invariant(false) : undefined;\n    EventPluginRegistry.plugins[pluginIndex] = PluginModule;\n    var publishedEvents = PluginModule.eventTypes;\n    for (var eventName in publishedEvents) {\n      !publishEventForPlugin(publishedEvents[eventName], PluginModule, eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Failed to publish event `%s` for plugin `%s`.', eventName, pluginName) : invariant(false) : undefined;\n    }\n  }\n}\n\n/**\n * Publishes an event so that it can be dispatched by the supplied plugin.\n *\n * @param {object} dispatchConfig Dispatch configuration for the event.\n * @param {object} PluginModule Plugin publishing the event.\n * @return {boolean} True if the event was successfully published.\n * @private\n */\nfunction publishEventForPlugin(dispatchConfig, PluginModule, eventName) {\n  !!EventPluginRegistry.eventNameDispatchConfigs.hasOwnProperty(eventName) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'event name, `%s`.', eventName) : invariant(false) : undefined;\n  EventPluginRegistry.eventNameDispatchConfigs[eventName] = dispatchConfig;\n\n  var phasedRegistrationNames = dispatchConfig.phasedRegistrationNames;\n  if (phasedRegistrationNames) {\n    for (var phaseName in phasedRegistrationNames) {\n      if (phasedRegistrationNames.hasOwnProperty(phaseName)) {\n        var phasedRegistrationName = phasedRegistrationNames[phaseName];\n        publishRegistrationName(phasedRegistrationName, PluginModule, eventName);\n      }\n    }\n    return true;\n  } else if (dispatchConfig.registrationName) {\n    publishRegistrationName(dispatchConfig.registrationName, PluginModule, eventName);\n    return true;\n  }\n  return false;\n}\n\n/**\n * Publishes a registration name that is used to identify dispatched events and\n * can be used with `EventPluginHub.putListener` to register listeners.\n *\n * @param {string} registrationName Registration name to add.\n * @param {object} PluginModule Plugin publishing the event.\n * @private\n */\nfunction publishRegistrationName(registrationName, PluginModule, eventName) {\n  !!EventPluginRegistry.registrationNameModules[registrationName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginHub: More than one plugin attempted to publish the same ' + 'registration name, `%s`.', registrationName) : invariant(false) : undefined;\n  EventPluginRegistry.registrationNameModules[registrationName] = PluginModule;\n  EventPluginRegistry.registrationNameDependencies[registrationName] = PluginModule.eventTypes[eventName].dependencies;\n}\n\n/**\n * Registers plugins so that they can extract and dispatch events.\n *\n * @see {EventPluginHub}\n */\nvar EventPluginRegistry = {\n\n  /**\n   * Ordered list of injected plugins.\n   */\n  plugins: [],\n\n  /**\n   * Mapping from event name to dispatch config\n   */\n  eventNameDispatchConfigs: {},\n\n  /**\n   * Mapping from registration name to plugin module\n   */\n  registrationNameModules: {},\n\n  /**\n   * Mapping from registration name to event name\n   */\n  registrationNameDependencies: {},\n\n  /**\n   * Injects an ordering of plugins (by plugin name). This allows the ordering\n   * to be decoupled from injection of the actual plugins so that ordering is\n   * always deterministic regardless of packaging, on-the-fly injection, etc.\n   *\n   * @param {array} InjectedEventPluginOrder\n   * @internal\n   * @see {EventPluginHub.injection.injectEventPluginOrder}\n   */\n  injectEventPluginOrder: function (InjectedEventPluginOrder) {\n    !!EventPluginOrder ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject event plugin ordering more than ' + 'once. You are likely trying to load more than one copy of React.') : invariant(false) : undefined;\n    // Clone the ordering so it cannot be dynamically mutated.\n    EventPluginOrder = Array.prototype.slice.call(InjectedEventPluginOrder);\n    recomputePluginOrdering();\n  },\n\n  /**\n   * Injects plugins to be used by `EventPluginHub`. The plugin names must be\n   * in the ordering injected by `injectEventPluginOrder`.\n   *\n   * Plugins can be injected as part of page initialization or on-the-fly.\n   *\n   * @param {object} injectedNamesToPlugins Map from names to plugin modules.\n   * @internal\n   * @see {EventPluginHub.injection.injectEventPluginsByName}\n   */\n  injectEventPluginsByName: function (injectedNamesToPlugins) {\n    var isOrderingDirty = false;\n    for (var pluginName in injectedNamesToPlugins) {\n      if (!injectedNamesToPlugins.hasOwnProperty(pluginName)) {\n        continue;\n      }\n      var PluginModule = injectedNamesToPlugins[pluginName];\n      if (!namesToPlugins.hasOwnProperty(pluginName) || namesToPlugins[pluginName] !== PluginModule) {\n        !!namesToPlugins[pluginName] ? process.env.NODE_ENV !== 'production' ? invariant(false, 'EventPluginRegistry: Cannot inject two different event plugins ' + 'using the same name, `%s`.', pluginName) : invariant(false) : undefined;\n        namesToPlugins[pluginName] = PluginModule;\n        isOrderingDirty = true;\n      }\n    }\n    if (isOrderingDirty) {\n      recomputePluginOrdering();\n    }\n  },\n\n  /**\n   * Looks up the plugin for the supplied event.\n   *\n   * @param {object} event A synthetic event.\n   * @return {?object} The plugin that created the supplied event.\n   * @internal\n   */\n  getPluginModuleForEvent: function (event) {\n    var dispatchConfig = event.dispatchConfig;\n    if (dispatchConfig.registrationName) {\n      return EventPluginRegistry.registrationNameModules[dispatchConfig.registrationName] || null;\n    }\n    for (var phase in dispatchConfig.phasedRegistrationNames) {\n      if (!dispatchConfig.phasedRegistrationNames.hasOwnProperty(phase)) {\n        continue;\n      }\n      var PluginModule = EventPluginRegistry.registrationNameModules[dispatchConfig.phasedRegistrationNames[phase]];\n      if (PluginModule) {\n        return PluginModule;\n      }\n    }\n    return null;\n  },\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _resetEventPlugins: function () {\n    EventPluginOrder = null;\n    for (var pluginName in namesToPlugins) {\n      if (namesToPlugins.hasOwnProperty(pluginName)) {\n        delete namesToPlugins[pluginName];\n      }\n    }\n    EventPluginRegistry.plugins.length = 0;\n\n    var eventNameDispatchConfigs = EventPluginRegistry.eventNameDispatchConfigs;\n    for (var eventName in eventNameDispatchConfigs) {\n      if (eventNameDispatchConfigs.hasOwnProperty(eventName)) {\n        delete eventNameDispatchConfigs[eventName];\n      }\n    }\n\n    var registrationNameModules = EventPluginRegistry.registrationNameModules;\n    for (var registrationName in registrationNameModules) {\n      if (registrationNameModules.hasOwnProperty(registrationName)) {\n        delete registrationNameModules[registrationName];\n      }\n    }\n  }\n\n};\n\nmodule.exports = EventPluginRegistry;\n};"],
"names":["shadow$provide","global","require","module","exports","recomputePluginOrdering","EventPluginOrder","pluginName","namesToPlugins","PluginModule","pluginIndex","indexOf","undefined","invariant","EventPluginRegistry","plugins","extractEvents","publishedEvents","eventTypes","eventName","phaseName","eventNameDispatchConfigs","hasOwnProperty","dispatchConfig","phasedRegistrationNames","publishRegistrationName","phasedRegistrationName","registrationName","registrationNameModules","registrationNameDependencies","dependencies","injectEventPluginOrder","InjectedEventPluginOrder","Array","prototype","slice","call","injectEventPluginsByName","injectedNamesToPlugins","isOrderingDirty","getPluginModuleForEvent","event","phase","_resetEventPlugins","length"]
}
