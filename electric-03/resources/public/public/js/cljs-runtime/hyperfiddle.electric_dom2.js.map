{"version":3,"sources":["hyperfiddle/electric_dom2.cljc"],"mappings":"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","names":["hyperfiddle.electric-dom2/nil-subject","!","var_args","args__5775__auto__","len__5769__auto__","i__5770__auto__","argseq__5776__auto__","cljs.core/IndexedSeq","hyperfiddle.electric-dom2/unsupported","seq48369","self__5755__auto__","cljs.core/seq","_","cljs.core.ex_info","hyperfiddle.electric-dom2/hook","x","G__48370","y","hyperfiddle.electric-dom2/by-id","id","js/document.getElementById","hyperfiddle.electric-dom2/new-node","parent","type","el","G__48371","cljs.core/Keyword","js/document","goog.dom/createTextNode","goog.dom/createElement","hyperfiddle.electric-dom2/-googDomSetTextContentNoWarn","node","str","goog.dom/setTextContent","hyperfiddle.electric-dom2/SVG-NS","hyperfiddle.electric-dom2/XLINK-NS","hyperfiddle.electric-dom2/alias->ns","hyperfiddle.electric-dom2/attr-alias","attr","cljs.core/second","cljs.core/re-find","cljs.core/name","hyperfiddle.electric-dom2/resolve-attr-alias","temp__5802__auto__","alias","clojure.string/replace-first","G__48373","hyperfiddle.electric-dom2/set-attribute-ns","js/Error","v","vec__48374","cljs.core.nth","ns","hyperfiddle.electric_dom2.set_attribute_ns","G__48378","hyperfiddle.electric-dom2/set-property!","k","hyperfiddle.electric_dom2.set_property_BANG_","cljs.core/clj->js","and__5043__auto__","G__48379","goog.style/setStyle","hyperfiddle.electric_dom2.goog$module$goog$object.get","goog.dom/DIRECT_ATTRIBUTE_MAP_","cljs.core._EQ_","hyperfiddle.electric_dom2.goog$module$goog$object.containsKey","hyperfiddle.electric_dom2.goog$module$goog$object.set","hyperfiddle.electric-dom2/unmount-prop","missionary.core/observe","hyperfiddle.electric-dom2/LAST-PROPS","hyperfiddle.electric-dom2/ordered-props","props-map","props","cljs.core.apply","cljs.core/dissoc","cljs.core.concat","cljs.core/select-keys","hyperfiddle.electric-dom2/parse-class","xs","G__48381","clojure.string.split","cljs.core/coll?","cljs.core.into","cljs.core.comp","cljs.core.filter","cljs.core/string?","cljs.core.remove","clojure.string/blank?","hyperfiddle.electric-dom2/register-class!","class","refs","or__5045__auto__","cljs.core.update","cnt","hyperfiddle.electric-dom2/unregister-class!","cljs.core.get","cljs.core.dissoc","cljs.core/dec","hyperfiddle.electric-dom2/set-val"],"sourcesContent":["(ns hyperfiddle.electric-dom2\r\n  (:refer-clojure :exclude [time])\r\n  (:require [contrib.missionary-contrib :as mx]\r\n            #?(:cljs goog.dom)\r\n            #?(:cljs goog.object)\r\n            #?(:cljs goog.style)\r\n            [hyperfiddle.electric :as e]\r\n            [missionary.core :as m]\r\n            [clojure.string :as str]\r\n            [contrib.data :as data])\r\n  (:import [hyperfiddle.electric Pending])\r\n  #?(:cljs (:require-macros [hyperfiddle.electric-dom2 :refer [with]])))\r\n\r\n(e/def node)\r\n(def nil-subject (fn [!] (! nil) #()))\r\n(e/def keepalive (new (m/observe nil-subject)))\r\n\r\n(defn unsupported [& _]\r\n  (throw (ex-info (str \"Not available on this peer.\") {})))\r\n\r\n(def hook \"See `with`\"\r\n  #?(:clj  unsupported\r\n     :cljs (fn ([x] (some-> (.-parentNode x) (.removeChild x)))\r\n             ([x y] (.insertBefore (.-parentNode x) x y))))) ; rotate siblings\r\n\r\n(defmacro with\r\n  \"Attach `body` to a dom node, which will be moved in the DOM when body moves in the DAG.\r\n  Given p/for semantics, `body` can only move sideways or be cancelled. If body is cancelled,\r\n  the node will be unmounted. If body moves, the node will rotate with its siblings.\"\r\n  [dom-node & body]\r\n  `(binding [node ~dom-node]\r\n     ; wrap body in a constant frame, so it can be moved as a block\r\n     (new (e/hook hook node (e/fn [] keepalive ~@body))))) ; todo remove\r\n\r\n#?(:cljs (defn by-id [id] (js/document.getElementById id)))\r\n\r\n#?(:cljs\r\n   (defn new-node [parent type]\r\n     (let [el (case type\r\n                :comment (.createComment js/document \"\")\r\n                :text (goog.dom/createTextNode \"\")\r\n                (goog.dom/createElement type))]\r\n       (.appendChild parent el)\r\n       el)))\r\n\r\n(defmacro element [t & body]\r\n  `(with (new-node node ~(name t))\r\n     ; hack: speed up streamy unmount by removing from layout first\r\n     ; it also feels faster visually\r\n     (e/on-unmount #(set! (.. node -style -display) \"none\")) ; hack\r\n     ~@body))\r\n\r\n#?(:cljs (defn -googDomSetTextContentNoWarn [node str]\r\n           ; Electric says :infer-warning Cannot infer target type in expression, fixme\r\n           (goog.dom/setTextContent node str)))\r\n\r\n(defmacro text [& strs]\r\n  `(do (assert (not= (.-nodeType node) (.-TEXT_NODE node))\r\n               \"userland directed dom/text inside dom/text, which is illegal\")\r\n       ~@(map (fn [str]\r\n                `(with (new-node node :text)\r\n                   (-googDomSetTextContentNoWarn node ~str)))\r\n           strs)))\r\n\r\n(defmacro comment_ [& strs]\r\n  (cons `do\r\n    (map (fn [str] `(with (new-node node :comment)\r\n                      (-googDomSetTextContentNoWarn node ~str)))\r\n      strs)))\r\n\r\n(def ^:const SVG-NS \"http://www.w3.org/2000/svg\")\r\n(def ^:const XLINK-NS \"http://www.w3.org/1999/xlink\")\r\n\r\n(def alias->ns {\"svg\" SVG-NS, \"xlink\" XLINK-NS})\r\n\r\n(defn attr-alias [attr] (second (re-find #\"^([^:]+):\" (name attr))))\r\n\r\n(defn resolve-attr-alias [attr]\r\n  (let [attr (name attr)]\r\n    (if-let [alias (attr-alias attr)]\r\n      (let [attr (-> (str/replace-first attr alias \"\")\r\n                   (str/replace-first #\"^:\" \"\"))]\r\n        [(alias->ns alias) attr])\r\n      [nil attr])))\r\n\r\n#?(:cljs\r\n   (defn set-attribute-ns\r\n     ([node attr v]\r\n      (let [[ns attr] (resolve-attr-alias attr)]\r\n        (set-attribute-ns node ns attr v)))\r\n     ([^js node ns attr v]\r\n      (.setAttributeNS node ns attr v))))\r\n\r\n#?(:cljs\r\n   (defn set-property!\r\n     ([node k v] (set-property! node (.-namespaceURI node) k v))\r\n     ([node ns k v]\r\n      (let [k (name k)\r\n            v (clj->js v)]\r\n        (if (and (nil? v) (.hasAttributeNS node nil k))\r\n          (.removeAttributeNS node nil k)\r\n          (case k\r\n            \"style\" (goog.style/setStyle node v)\r\n            \"list\"  (set-attribute-ns node nil k v) ; corner case, list (datalist) is setted by attribute and readonly as a prop.\r\n            (if-let [k (goog.object/get goog.dom/DIRECT_ATTRIBUTE_MAP_ k)]\r\n              (set-attribute-ns node k v)\r\n              (if (= SVG-NS ns)\r\n                (set-attribute-ns node k v)\r\n                (if (goog.object/containsKey node k) ; is there an object property for this key?\r\n                  (goog.object/set node k v)\r\n                  (set-attribute-ns node k v))))))))))\r\n\r\n#?(:cljs (defn unmount-prop [node k v]\r\n           (m/observe (fn [!] (! nil) #(set-property! node k v)))))\r\n\r\n(defmacro style [m]\r\n  (if (map? m)\r\n    `(do ~@(mapcat (fn [[k v]] [`(set-property! node \"style\" {~k ~v})\r\n                                `(new (unmount-prop node \"style\" {~k nil}))]) m)\r\n         nil) ; static keyset\r\n    `(e/for-by first [sty# (vec ~m)]\r\n       (set-property! node \"style\" {(key sty#) (val sty#)})\r\n       (new (unmount-prop node {(key sty#) nil}))\r\n       nil)))\r\n\r\n\r\n(def LAST-PROPS\r\n  \"Due to a bug in both Webkit and FF, input type range's knob renders in the\r\n  wrong place if value is set after `min` and `max`, and `max` is above 100.\r\n  Other UI libs circumvent this issue by setting `value` last.\"\r\n [:value ::value])\r\n\r\n(defn ordered-props \"Sort props by key to ensure they are applied in a predefined order. See `LAST-PROPS`.\"\r\n  [props-map]\r\n  (let [props (apply dissoc props-map LAST-PROPS)]\r\n    (concat (seq props) (seq (select-keys props-map LAST-PROPS)))))\r\n\r\n(defn parse-class [xs]\r\n  (cond (string? xs) (parse-class (str/split xs #\"\\s+\"))\r\n        (coll? xs)   (into [] (comp (filter string?) (remove str/blank?)) xs)\r\n        :else        nil))\r\n\r\n#?(:cljs\r\n   (defn register-class! [^js node class]\r\n     (let [refs (or (.-hyperfiddle_electric_dom2_class_refs node) {})]\r\n       (.add (.-classList node) class)\r\n       (set! (.-hyperfiddle_electric_dom2_class_refs node) (update refs class (fn [cnt] (inc (or cnt 0))))))))\r\n\r\n#?(:cljs\r\n   (defn unregister-class! [^js node class]\r\n     (let [refs (or (.-hyperfiddle_electric_dom2_class_refs node) {})\r\n           refs (if (= 1 (get refs class))\r\n                  (do (.remove (.-classList node) class)\r\n                      (dissoc refs class))\r\n                  (update refs class dec))]\r\n       (set! (.-hyperfiddle_electric_dom2_class_refs node) refs))))\r\n\r\n(e/defn ClassList [node classes]\r\n  (e/for [class classes]\r\n    (new (m/relieve {} (m/observe (fn [!]\r\n                                    (! nil)\r\n                                    (register-class! node class)\r\n                                    #(unregister-class! node class)))))))\r\n\r\n;; TODO JS runtimes intern litteral strings, so call `name` on keywords at\r\n;; macroexpension.\r\n(defmacro props [m]\r\n  (let [style? #{:style ::style}       ; TODO disambiguate\r\n        class? #{:class ::class}]\r\n    (if (map? m)\r\n      `(do ~@(mapcat (fn [[k v]] (cond  ; static keyset\r\n                                   (style? k) [`(style ~v)]\r\n                                   (class? k) [`(new ClassList node (parse-class ~v))]\r\n                                   :else      [`(set-property! node ~k ~v)\r\n                                          `(new (unmount-prop node ~k nil))]))\r\n               (ordered-props m))\r\n           nil)\r\n      `(e/for-by key [prop# (vec (ordered-props ~m))]\r\n         (cond\r\n           (~style? (key prop#)) (style (val prop#))\r\n           (~class? (key prop#)) (new ClassList node (parse-class (val prop#)))\r\n           :else                 (do (set-property! node (key prop#) (val prop#))\r\n                                     (new (unmount-prop node (key prop#) nil))\r\n                                     nil))))))\r\n\r\n(defmacro on!\r\n  \"Call the `callback` clojure function on event.\r\n   (on! \\\"click\\\" (fn [event] ...)) \"\r\n  ([event-name callback] `(on! node ~event-name ~callback))\r\n  ([dom-node event-name callback] `(on! ~dom-node ~event-name ~callback nil))\r\n  ([dom-node event-name callback options] \r\n   `(new (->> (e/listen> ~dom-node ~event-name ~callback ~options)\r\n           (m/reductions {} nil)))))\r\n\r\n(defmacro ^:deprecated ^:no-doc event \"Deprecated, please use `on!`\" [& args] `(on! ~@args))\r\n(e/def ^:deprecated system-time-ms e/system-time-ms)\r\n(e/def ^:deprecated system-time-secs e/system-time-secs)\r\n\r\n(defmacro on\r\n  \"Run the given electric function on event.\r\n  (on \\\"click\\\" (e/fn [event] ...))\"\r\n  ;; TODO add support of event options (see `event*`)\r\n  ;(^:deprecated [typ]  `(new Event ~typ false)) ; use `on!` for local side effects\r\n  ([typ F] `(on node ~typ ~F))\r\n  ([node typ F] `(binding [node ~node]\r\n                   (let [[state# v#] (e/for-event-pending-switch [e# (e/listen> node ~typ)] (new ~F e#))]\r\n                     (case state#\r\n                       (::e/init ::e/ok) v# ; could be `nil`, for backward compat we keep it\r\n                       (::e/pending) (throw (Pending.))\r\n                       (::e/failed)  (throw v#))))))\r\n\r\n#?(:cljs (e/def visibility-state \"'hidden' | 'visible'\"\r\n           (new (->> (e/listen> js/document \"visibilitychange\")\r\n                  (m/reductions {} nil)\r\n                  (m/latest #(.-visibilityState js/document))))))\r\n\r\n(defmacro on-pending [pending-body & body] `(try (do ~@body) (catch Pending e# ~pending-body (throw e#))))\r\n\r\n(e/defn Focused? \"Returns whether this DOM `node` is focused.\"\r\n  []\r\n  (->> (mx/mix\r\n         (e/listen> node \"focus\" (constantly true))\r\n         (e/listen> node \"blur\" (constantly false)))\r\n    (m/reductions {} (= node (.-activeElement js/document)))\r\n    (m/relieve {})\r\n    new))\r\n\r\n#?(:cljs (defn set-val [node v] (set! (.-value node) (str v))))\r\n\r\n(defmacro bind-value\r\n  ([v]        `(bind-value ~v set-val))\r\n  ([v setter] `(when-some [v# (when-not (new Focused?) ~v)]\r\n                 (~setter node v#))))\r\n\r\n(e/defn Hovered? \"Returns whether this DOM `node` is hovered over.\"\r\n  []\r\n  (->> (mx/mix\r\n         (e/listen> node \"mouseenter\" (constantly true))\r\n         (e/listen> node \"mouseleave\" (constantly false)))\r\n    (m/reductions {} false)\r\n    (m/relieve {})\r\n    new))\r\n\r\n(defmacro a [& body] `(element :a ~@body))\r\n(defmacro abbr [& body] `(element :abbr ~@body))\r\n(defmacro address [& body] `(element :address ~@body))\r\n(defmacro area [& body] `(element :area ~@body))\r\n(defmacro article [& body] `(element :article ~@body))\r\n(defmacro aside [& body] `(element :aside ~@body))\r\n(defmacro audio [& body] `(element :audio ~@body))\r\n(defmacro b [& body] `(element :b ~@body))\r\n(defmacro bdi [& body] `(element :bdi ~@body))\r\n(defmacro bdo [& body] `(element :bdo ~@body))\r\n(defmacro blockquote [& body] `(element :blockquote ~@body))\r\n(defmacro br [& body] `(element :br ~@body))\r\n(defmacro button [& body] `(element :button ~@body))\r\n(defmacro canvas [& body] `(element :canvas ~@body))\r\n(defmacro cite [& body] `(element :cite ~@body))\r\n(defmacro code [& body] `(element :code ~@body))\r\n(defmacro data [& body] `(element :data ~@body))\r\n(defmacro datalist [& body] `(element :datalist ~@body))\r\n(defmacro del [& body] `(element :del ~@body))\r\n(defmacro details [& body] `(element :details ~@body))\r\n(defmacro dfn [& body] `(element :dfn ~@body))\r\n(defmacro dialog [& body] `(element :dialog ~@body))\r\n(defmacro div [& body] `(element :div ~@body))\r\n(defmacro dl \"The <dl> HTML element represents a description list. The element encloses a list of groups of terms (specified using the <dt> element) and descriptions (provided by <dd> elements). Common uses for this element are to implement a glossary or to display metadata (a list of key-value pairs).\" [& body] `(element :dl ~@body))\r\n(defmacro dt \"The <dt> HTML element specifies a term in a description or definition list, and as such must be used inside a <dl> element. It is usually followed by a <dd> element; however, multiple <dt> elements in a row indicate several terms that are all defined by the immediate next <dd> element.\" [& body] `(element :dt ~@body))\r\n(defmacro dd \"The <dd> HTML element provides the description, definition, or value for the preceding term (<dt>) in a description list (<dl>).\" [& body] `(element :dd ~@body))\r\n(defmacro em [& body] `(element :em ~@body))\r\n(defmacro embed [& body] `(element :embed ~@body))\r\n(defmacro fieldset [& body] `(element :fieldset ~@body))\r\n(defmacro figure [& body] `(element :figure ~@body))\r\n(defmacro footer [& body] `(element :footer ~@body))\r\n(defmacro form [& body] `(element :form ~@body))\r\n(defmacro h1 [& body] `(element :h1 ~@body))\r\n(defmacro h2 [& body] `(element :h2 ~@body))\r\n(defmacro h3 [& body] `(element :h3 ~@body))\r\n(defmacro h4 [& body] `(element :h4 ~@body))\r\n(defmacro h5 [& body] `(element :h5 ~@body))\r\n(defmacro h6 [& body] `(element :h6 ~@body))\r\n(defmacro header [& body] `(element :header ~@body))\r\n(defmacro hgroup [& body] `(element :hgroup ~@body))\r\n(defmacro hr [& body] `(element :hr ~@body))\r\n(defmacro i [& body] `(element :i ~@body))\r\n(defmacro iframe [& body] `(element :iframe ~@body))\r\n(defmacro img [& body] `(element :img ~@body))\r\n(defmacro input [& body] `(element :input ~@body))\r\n(defmacro ins [& body] `(element :ins ~@body))\r\n(defmacro kbd [& body] `(element :kbd ~@body))\r\n(defmacro label [& body] `(element :label ~@body))\r\n(defmacro legend [& body] `(element :legend ~@body))\r\n(defmacro li [& body] `(element :li ~@body))\r\n(defmacro link [& body] `(element :link ~@body))\r\n(defmacro main [& body] `(element :main ~@body))\r\n#_(defmacro map [& body] `(element :map ~@body))\r\n(defmacro mark [& body] `(element :mark ~@body))\r\n(defmacro math [& body] `(element :math ~@body))\r\n(defmacro menu [& body] `(element :menu ~@body))\r\n(defmacro itemprop [& body] `(element :itemprop ~@body))\r\n(defmacro meter [& body] `(element :meter ~@body))\r\n(defmacro nav [& body] `(element :nav ~@body))\r\n(defmacro noscript [& body] `(element :noscript ~@body))\r\n(defmacro object [& body] `(element :object ~@body))\r\n(defmacro ol [& body] `(element :ol ~@body))\r\n(defmacro option [& body] `(element :option ~@body))\r\n(defmacro optgroup [& body] `(element :optgroup ~@body))\r\n(defmacro output [& body] `(element :output ~@body))\r\n(defmacro p [& body] `(element :p ~@body))\r\n(defmacro picture [& body] `(element :picture ~@body))\r\n(defmacro pre [& body] `(element :pre ~@body))\r\n(defmacro progress [& body] `(element :progress ~@body))\r\n(defmacro q [& body] `(element :q ~@body))\r\n(defmacro ruby [& body] `(element :ruby ~@body))\r\n(defmacro s [& body] `(element :s ~@body))\r\n(defmacro samp [& body] `(element :samp ~@body))\r\n(defmacro script [& body] `(element :script ~@body))\r\n(defmacro section [& body] `(element :section ~@body))\r\n(defmacro select [& body] `(element :select ~@body))\r\n(defmacro slot [& body] `(element :slot ~@body))\r\n(defmacro small [& body] `(element :small ~@body))\r\n(defmacro span [& body] `(element :span ~@body))\r\n(defmacro strong [& body] `(element :strong ~@body))\r\n(defmacro sub [& body] `(element :sub ~@body))\r\n(defmacro summary [& body] `(element :summary ~@body))\r\n(defmacro sup [& body] `(element :sup ~@body))\r\n(defmacro table [& body] `(element :table ~@body))\r\n(defmacro tbody [& body] `(element :tbody ~@body))\r\n(defmacro td [& body] `(element :td ~@body))\r\n(defmacro th [& body] `(element :th ~@body))\r\n(defmacro thead [& body] `(element :thead ~@body))\r\n(defmacro tr [& body] `(element :tr ~@body))\r\n(defmacro template [& body] `(element :template ~@body))\r\n(defmacro textarea [& body] `(element :textarea ~@body))\r\n(defmacro time [& body] `(element :time ~@body))\r\n(defmacro u [& body] `(element :u ~@body))\r\n(defmacro ul [& body] `(element :ul ~@body))\r\n(defmacro var [& body] `(element :var ~@body))\r\n(defmacro video [& body] `(element :video ~@body))\r\n(defmacro wbr [& body] `(element :wbr ~@body))\r\n"]}