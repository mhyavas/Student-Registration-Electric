{
"version":3,
"file":"module$node_modules$react_offcanvas$node_modules$react$lib$ReactEventListener.js",
"lineCount":7,
"mappings":"AAAAA,cAAA,CAAA,6EAAA,CAAkG,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CA+C1IC,QAASA,4BAA2B,CAACC,YAAD,CAAeC,WAAf,CAA4B,CAC9D,IAAKD,CAAAA,YAAL,CAAoBA,YACpB,KAAKC,CAAAA,WAAL,CAAmBA,WACnB,KAAKC,CAAAA,SAAL,CAAiB,EAH6C,CAchEC,QAASA,mBAAkB,CAACC,WAAD,CAAc,CAWvC,IAAKC,EAaL,KAPA,IAAIC,eAAiBC,UAAWC,CAAAA,gBAAX,CAA4BC,cAAA,CALvBL,WAKkDH,CAAAA,WAA3B,CAA5B,CAAjBK,EAAyFI,MAO7F,CAAOC,cAAP,CAAA,CAZ0BP,WAaZF,CAAAA,SAAUU,CAAAA,IAAtB,CAA2BD,cAA3B,CA3CF,CAJIE,cAIJ,CAJaN,UAAWO,CAAAA,KAAX,CAgDWH,cAhDX,CAIb;AAHII,cAGJ,CAHaC,oBAAqBC,CAAAA,wBAArB,CAA8CJ,cAA9C,CAGb,CAFIK,cAEJ,CAFgBX,UAAWY,CAAAA,uBAAX,CAAmCJ,cAAnC,CAEhB,CAAA,cAAA,CADaR,UAAWC,CAAAA,gBAAXY,CAA4BF,cAA5BE,CAgDb,KAAK,IAAIC,EAAI,CAAb,CAAgBA,CAAhB,CAjB0BjB,WAiBMF,CAAAA,SAAUoB,CAAAA,MAA1C,CAAkDD,CAAA,EAAlD,CAAuD,CACrDf,cAAA,CAlBwBF,WAkBKF,CAAAA,SAAZ,CAAsBmB,CAAtB,CACjB,KAAIE,iBAAmBhB,UAAWO,CAAAA,KAAX,CAAiBR,cAAjB,CAAnBiB,EAAuD,EAC3DC,mBAAmBC,CAAAA,eAAnB,CApBwBrB,WAoBuBJ,CAAAA,YAA/C,CAA6DM,cAA7D,CAA6EiB,gBAA7E,CApBwBnB,WAoBmFH,CAAAA,WAA3G,CAAwHQ,cAAA,CApBhGL,WAoB2HH,CAAAA,WAA3B,CAAxH,CAHqD,CA7BhB;AAsEzCyB,QAASA,mBAAkB,CAACC,EAAD,CAAK,CAC9B,IAAIC,eAAiBC,0BAAA,CAA2BnB,MAA3B,CACrBiB,GAAA,CAAGC,cAAH,CAF8B,CApHhC,IAAIE,cAAgBlC,OAAA,CAAQ,4CAAR,CAChBmC,OAAAA,CAAuBnC,OAAA,CAAQ,mDAAR,CACvBoC,QAAAA,CAAcpC,OAAA,CAAQ,wEAAR,CAClB,KAAIoB,qBAAuBpB,OAAA,CAAQ,iFAAR,CAA3B,CACIW,WAAaX,OAAA,CAAQ,uEAAR,CADjB;AAEIqC,aAAerC,OAAA,CAAQ,yEAAR,CAFnB,CAIIsC,OAAStC,OAAA,CAAQ,0EAAR,CAJb,CAKIa,eAAiBb,OAAA,CAAQ,2EAAR,CALrB,CAMIiC,2BAA6BjC,OAAA,CAAQ,yDAAR,CA4BjCsC,OAAA,CAAOnC,2BAA4BoC,CAAAA,SAAnC,CAA8C,CAC5CC,WAAYA,QAAS,EAAG,CAEtB,IAAKnC,CAAAA,WAAL,CADA,IAAKD,CAAAA,YACL,CADoB,IAEpB,KAAKE,CAAAA,SAAUoB,CAAAA,MAAf;AAAwB,CAHF,CADoB,CAA9C,CAOAU,QAAYK,CAAAA,YAAZ,CAAyBtC,2BAAzB,CAAsDiC,OAAYM,CAAAA,iBAAlE,CA6EA,KAAId,mBAAqB,CACvBe,SAAU,CAAA,CADa,CAEvBd,gBAAiB,IAFM,CAIvBe,cAAeT,MAAqBU,CAAAA,SAArB,CAAiC/B,MAAjC,CAA0C,IAJlC,CAMvBgC,kBAAmBA,QAAS,CAACC,cAAD,CAAiB,CAC3CnB,kBAAmBC,CAAAA,eAAnB,CAAqCkB,cADM,CANtB,CAUvBC,WAAYA,QAAS,CAACC,OAAD,CAAU,CAC7BrB,kBAAmBe,CAAAA,QAAnB,CAA8B,CAAC,CAACM,OADH,CAVR,CAcvBC,UAAWA,QAAS,EAAG,CACrB,MAAOtB,mBAAmBe,CAAAA,QADL,CAdA,CA4BvBQ,iBAAkBA,QAAS,CAAC/C,YAAD,CAAegD,eAAf,CAAgCC,MAAhC,CAAwC,CAEjE,MADcA,OACd,CAGOnB,aAAcoB,CAAAA,MAAd,CAJOD,MAIP;AAA8BD,eAA9B,CAA+CxB,kBAAmB2B,CAAAA,aAAcC,CAAAA,IAAjC,CAAsC,IAAtC,CAA4CpD,YAA5C,CAA/C,CAHP,CACS,IAHwD,CA5B5C,CA8CvBqD,kBAAmBA,QAAS,CAACrD,YAAD,CAAegD,eAAf,CAAgCC,MAAhC,CAAwC,CAElE,MADcA,OACd,CAGOnB,aAAcwB,CAAAA,OAAd,CAJOL,MAIP,CAA+BD,eAA/B,CAAgDxB,kBAAmB2B,CAAAA,aAAcC,CAAAA,IAAjC,CAAsC,IAAtC,CAA4CpD,YAA5C,CAAhD,CAHP,CACS,IAHyD,CA9C7C,CAsDvBuD,mBAAoBA,QAAS,CAACC,OAAD,CAAU,CACjCC,OAAAA,CAAW/B,kBAAmB0B,CAAAA,IAAnB,CAAwB,IAAxB,CAA8BI,OAA9B,CACf1B,cAAcoB,CAAAA,MAAd,CAAqBxC,MAArB,CAA6B,QAA7B,CAAuC+C,OAAvC,CAFqC,CAtDhB,CA2DvBN,cAAeA,QAAS,CAACnD,YAAD,CAAeC,WAAf,CAA4B,CAClD,GAAKuB,kBAAmBe,CAAAA,QAAxB,CAAA,CAIInC,YAAAA,CAAcL,2BAA4B2D,CAAAA,SAA5B,CAAsC1D,YAAtC;AAAoDC,WAApD,CAClB,IAAI,CAGFgC,YAAa0B,CAAAA,cAAb,CAA4BxD,kBAA5B,CAAgDC,YAAhD,CAHE,CAAJ,OAIU,CACRL,2BAA4B6D,CAAAA,OAA5B,CAAoCxD,YAApC,CADQ,CATV,CADkD,CA3D7B,CA2EzBP,OAAOC,CAAAA,OAAP,CAAiB0B,kBAnNyH;",
"sources":["node_modules/react-offcanvas/node_modules/react/lib/ReactEventListener.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$react_offcanvas$node_modules$react$lib$ReactEventListener\"] = function(global,require,module,exports) {\n/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactEventListener\n * @typechecks static-only\n */\n\n'use strict';\n\nvar EventListener = require('fbjs/lib/EventListener');\nvar ExecutionEnvironment = require('fbjs/lib/ExecutionEnvironment');\nvar PooledClass = require('./PooledClass');\nvar ReactInstanceHandles = require('./ReactInstanceHandles');\nvar ReactMount = require('./ReactMount');\nvar ReactUpdates = require('./ReactUpdates');\n\nvar assign = require('./Object.assign');\nvar getEventTarget = require('./getEventTarget');\nvar getUnboundedScrollPosition = require('fbjs/lib/getUnboundedScrollPosition');\n\nvar DOCUMENT_FRAGMENT_NODE_TYPE = 11;\n\n/**\n * Finds the parent React component of `node`.\n *\n * @param {*} node\n * @return {?DOMEventTarget} Parent container, or `null` if the specified node\n *                           is not nested.\n */\nfunction findParent(node) {\n  // TODO: It may be a good idea to cache this to prevent unnecessary DOM\n  // traversal, but caching is difficult to do correctly without using a\n  // mutation observer to listen for all DOM changes.\n  var nodeID = ReactMount.getID(node);\n  var rootID = ReactInstanceHandles.getReactRootIDFromNodeID(nodeID);\n  var container = ReactMount.findReactContainerForID(rootID);\n  var parent = ReactMount.getFirstReactDOM(container);\n  return parent;\n}\n\n// Used to store ancestor hierarchy in top level callback\nfunction TopLevelCallbackBookKeeping(topLevelType, nativeEvent) {\n  this.topLevelType = topLevelType;\n  this.nativeEvent = nativeEvent;\n  this.ancestors = [];\n}\nassign(TopLevelCallbackBookKeeping.prototype, {\n  destructor: function () {\n    this.topLevelType = null;\n    this.nativeEvent = null;\n    this.ancestors.length = 0;\n  }\n});\nPooledClass.addPoolingTo(TopLevelCallbackBookKeeping, PooledClass.twoArgumentPooler);\n\nfunction handleTopLevelImpl(bookKeeping) {\n  // TODO: Re-enable event.path handling\n  //\n  // if (bookKeeping.nativeEvent.path && bookKeeping.nativeEvent.path.length > 1) {\n  //   // New browsers have a path attribute on native events\n  //   handleTopLevelWithPath(bookKeeping);\n  // } else {\n  //   // Legacy browsers don't have a path attribute on native events\n  //   handleTopLevelWithoutPath(bookKeeping);\n  // }\n\n  void handleTopLevelWithPath; // temporarily unused\n  handleTopLevelWithoutPath(bookKeeping);\n}\n\n// Legacy browsers don't have a path attribute on native events\nfunction handleTopLevelWithoutPath(bookKeeping) {\n  var topLevelTarget = ReactMount.getFirstReactDOM(getEventTarget(bookKeeping.nativeEvent)) || window;\n\n  // Loop through the hierarchy, in case there's any nested components.\n  // It's important that we build the array of ancestors before calling any\n  // event handlers, because event handlers can modify the DOM, leading to\n  // inconsistencies with ReactMount's node cache. See #1105.\n  var ancestor = topLevelTarget;\n  while (ancestor) {\n    bookKeeping.ancestors.push(ancestor);\n    ancestor = findParent(ancestor);\n  }\n\n  for (var i = 0; i < bookKeeping.ancestors.length; i++) {\n    topLevelTarget = bookKeeping.ancestors[i];\n    var topLevelTargetID = ReactMount.getID(topLevelTarget) || '';\n    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, topLevelTarget, topLevelTargetID, bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));\n  }\n}\n\n// New browsers have a path attribute on native events\nfunction handleTopLevelWithPath(bookKeeping) {\n  var path = bookKeeping.nativeEvent.path;\n  var currentNativeTarget = path[0];\n  var eventsFired = 0;\n  for (var i = 0; i < path.length; i++) {\n    var currentPathElement = path[i];\n    if (currentPathElement.nodeType === DOCUMENT_FRAGMENT_NODE_TYPE) {\n      currentNativeTarget = path[i + 1];\n    }\n    // TODO: slow\n    var reactParent = ReactMount.getFirstReactDOM(currentPathElement);\n    if (reactParent === currentPathElement) {\n      var currentPathElementID = ReactMount.getID(currentPathElement);\n      var newRootID = ReactInstanceHandles.getReactRootIDFromNodeID(currentPathElementID);\n      bookKeeping.ancestors.push(currentPathElement);\n\n      var topLevelTargetID = ReactMount.getID(currentPathElement) || '';\n      eventsFired++;\n      ReactEventListener._handleTopLevel(bookKeeping.topLevelType, currentPathElement, topLevelTargetID, bookKeeping.nativeEvent, currentNativeTarget);\n\n      // Jump to the root of this React render tree\n      while (currentPathElementID !== newRootID) {\n        i++;\n        currentPathElement = path[i];\n        currentPathElementID = ReactMount.getID(currentPathElement);\n      }\n    }\n  }\n  if (eventsFired === 0) {\n    ReactEventListener._handleTopLevel(bookKeeping.topLevelType, window, '', bookKeeping.nativeEvent, getEventTarget(bookKeeping.nativeEvent));\n  }\n}\n\nfunction scrollValueMonitor(cb) {\n  var scrollPosition = getUnboundedScrollPosition(window);\n  cb(scrollPosition);\n}\n\nvar ReactEventListener = {\n  _enabled: true,\n  _handleTopLevel: null,\n\n  WINDOW_HANDLE: ExecutionEnvironment.canUseDOM ? window : null,\n\n  setHandleTopLevel: function (handleTopLevel) {\n    ReactEventListener._handleTopLevel = handleTopLevel;\n  },\n\n  setEnabled: function (enabled) {\n    ReactEventListener._enabled = !!enabled;\n  },\n\n  isEnabled: function () {\n    return ReactEventListener._enabled;\n  },\n\n  /**\n   * Traps top-level events by using event bubbling.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} handle Element on which to attach listener.\n   * @return {?object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapBubbledEvent: function (topLevelType, handlerBaseName, handle) {\n    var element = handle;\n    if (!element) {\n      return null;\n    }\n    return EventListener.listen(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));\n  },\n\n  /**\n   * Traps a top-level event by using event capturing.\n   *\n   * @param {string} topLevelType Record from `EventConstants`.\n   * @param {string} handlerBaseName Event name (e.g. \"click\").\n   * @param {object} handle Element on which to attach listener.\n   * @return {?object} An object with a remove function which will forcefully\n   *                  remove the listener.\n   * @internal\n   */\n  trapCapturedEvent: function (topLevelType, handlerBaseName, handle) {\n    var element = handle;\n    if (!element) {\n      return null;\n    }\n    return EventListener.capture(element, handlerBaseName, ReactEventListener.dispatchEvent.bind(null, topLevelType));\n  },\n\n  monitorScrollValue: function (refresh) {\n    var callback = scrollValueMonitor.bind(null, refresh);\n    EventListener.listen(window, 'scroll', callback);\n  },\n\n  dispatchEvent: function (topLevelType, nativeEvent) {\n    if (!ReactEventListener._enabled) {\n      return;\n    }\n\n    var bookKeeping = TopLevelCallbackBookKeeping.getPooled(topLevelType, nativeEvent);\n    try {\n      // Event queue being processed in the same cycle allows\n      // `preventDefault`.\n      ReactUpdates.batchedUpdates(handleTopLevelImpl, bookKeeping);\n    } finally {\n      TopLevelCallbackBookKeeping.release(bookKeeping);\n    }\n  }\n};\n\nmodule.exports = ReactEventListener;\n};"],
"names":["shadow$provide","global","require","module","exports","TopLevelCallbackBookKeeping","topLevelType","nativeEvent","ancestors","handleTopLevelImpl","bookKeeping","handleTopLevelWithPath","topLevelTarget","ReactMount","getFirstReactDOM","getEventTarget","window","ancestor","push","nodeID","getID","rootID","ReactInstanceHandles","getReactRootIDFromNodeID","container","findReactContainerForID","parent","i","length","topLevelTargetID","ReactEventListener","_handleTopLevel","scrollValueMonitor","cb","scrollPosition","getUnboundedScrollPosition","EventListener","ExecutionEnvironment","PooledClass","ReactUpdates","assign","prototype","destructor","addPoolingTo","twoArgumentPooler","_enabled","WINDOW_HANDLE","canUseDOM","setHandleTopLevel","handleTopLevel","setEnabled","enabled","isEnabled","trapBubbledEvent","handlerBaseName","handle","listen","dispatchEvent","bind","trapCapturedEvent","capture","monitorScrollValue","refresh","callback","getPooled","batchedUpdates","release"]
}
