{"version":3,"sources":["contrib/gridsheet.cljc"],"mappings":";;;;AAYA,AAwEA","names":[],"sourcesContent":["(ns contrib.gridsheet\r\n  \"todo deprecate, use HFQL grid. Used by datomic-browser and folder-explorer\"\r\n  #?(:cljs (:require-macros contrib.gridsheet))\r\n  (:require clojure.math\r\n            [contrib.assert :refer [check]]\r\n            [contrib.data :refer [auto-props round-floor]]\r\n            [hyperfiddle.electric :as e]\r\n            [hyperfiddle.electric-dom2 :as dom]\r\n            [hyperfiddle.electric-ui4 :as ui]\r\n            [hyperfiddle.history :as router] ; todo remove\r\n            #?(:cljs goog.object)))\r\n\r\n(e/defn GridSheet [xs props]\r\n  (let [props (auto-props props\r\n                {::row-height 24\r\n                 ::page-size 20})\r\n        {:keys [::Format\r\n                ::columns\r\n                ::grid-template-columns\r\n                ::row-height ; px, same unit as scrollTop\r\n                ::page-size #_ \"tight\"]} props\r\n        Format (or Format (e/fn [m a] (e/client (dom/text (pr-str (a m))))))\r\n        client-height (* (inc (check number? page-size)) (check number? row-height))\r\n        rows (seq xs)\r\n        row-count (count rows)]\r\n    (assert columns \"gridsheet: ::columns prop is required\")\r\n    (e/client\r\n      (dom/div (dom/props {:role \"grid\"\r\n                           :class (e/server (::dom/class props))\r\n                           :style (merge (e/server (::dom/style props))\r\n                                    {:height (str client-height \"px\")\r\n                                     :display \"grid\" :overflowY \"auto\"\r\n                                     :grid-template-columns (or (e/server (::grid-template-columns props))\r\n                                                              (->> (repeat (e/server (count columns)) \"1fr\")\r\n                                                                (interpose \" \") (apply str)))})})\r\n        (let [[scroll-top scroll-height client-height'] (new (ui/scroll-state< dom/node))\r\n              max-height (* row-count row-height)\r\n              padding-bottom (js/Math.max (- max-height client-height) 0)\r\n\r\n              ; don't scroll past the end\r\n              clamped-scroll-top (js/Math.min scroll-top padding-bottom)\r\n\r\n              start-row (clojure.math/ceil (/ clamped-scroll-top row-height))\r\n\r\n              ; batch pagination to improve latency\r\n              ; (does reducing network even help or just making loads happen offscreen?)\r\n              ; clamp start to the nearest page\r\n              start-row-page-aligned (round-floor start-row page-size)]\r\n          #_(println [:scrollTop scroll-top :scrollHeight scroll-height :clientHeight client-height\r\n                    :padding-bottom padding-bottom\r\n                    :start-row start-row :start-row-page-aligned start-row-page-aligned\r\n                    :take page-size :max-height max-height])\r\n\r\n          (e/for [k columns]\r\n            (dom/div (dom/props {:role \"columnheader\"\r\n                                 :style {:position \"sticky\" #_\"fixed\" :top (str 0 \"px\")\r\n                                         :background-color \"rgb(248 250 252)\" :box-shadow \"0 1px gray\"}})\r\n              (dom/text (name k))))\r\n\r\n          ; userland could format the row, no need\r\n          ; for grid to be aware of columns, it's just vertical scroll.\r\n          ; horizontal scroll changes things.\r\n          ; except for the tricky styles ...\r\n          (e/server\r\n            (when (seq rows) (check vector? (first rows)))\r\n            (let [xs (vec (->> rows (drop start-row) (take page-size)))]\r\n              (e/for [i (range page-size)]\r\n                (let [[depth m] (get xs i [0 ::empty])]\r\n                  (e/client\r\n                    (dom/div (dom/props {:role \"group\" :style {:display \"contents\"\r\n                                                               :grid-row (inc i)}})\r\n                      (dom/div (dom/props {:role \"gridcell\"\r\n                                           :style {:padding-left (-> depth (* 15) (str \"px\"))\r\n                                                   :position \"sticky\" :top (str (* row-height (inc i)) \"px\")\r\n                                                   :height (str row-height \"px\")}})\r\n                        (e/server (case m ::empty nil (Format. m (first columns))))) ; for effect\r\n                      (e/for [a (rest columns)]\r\n                        (dom/div (dom/props {:role \"gridcell\"\r\n                                             :style {:position \"sticky\" :top (str (* row-height (inc i)) \"px\")\r\n                                                     :height (str row-height \"px\")}})\r\n                          (e/server (case m ::empty nil (Format. m a))))))))))) ; for effect\r\n          (dom/div (dom/props {:style {:padding-bottom (str padding-bottom \"px\")}})))) ; scrollbar\r\n      (dom/div (dom/text (pr-str {:count row-count}))))))\r\n\r\n(e/defn Explorer [query-fn props]\r\n  (e/client\r\n    (let [{:keys [::search] :as s} router/route]\r\n      (ui/input search (e/fn V! [v] (router/swap-route! assoc ::search v)) ; todo (swap! router/!route assoc ::search v)\r\n        (dom/props {:placeholder \"Search\" :type \"search\"}))\r\n      (dom/hr)\r\n      (e/server\r\n        (GridSheet. (query-fn search) props)))))"]}