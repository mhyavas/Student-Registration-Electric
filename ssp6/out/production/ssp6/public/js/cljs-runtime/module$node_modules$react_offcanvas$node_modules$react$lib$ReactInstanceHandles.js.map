{
"version":3,
"file":"module$node_modules$react_offcanvas$node_modules$react$lib$ReactInstanceHandles.js",
"lineCount":8,
"mappings":"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",
"sources":["node_modules/react-offcanvas/node_modules/react/lib/ReactInstanceHandles.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$react_offcanvas$node_modules$react$lib$ReactInstanceHandles\"] = function(global,require,module,exports) {\n/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactInstanceHandles\n * @typechecks static-only\n */\n\n'use strict';\n\nvar ReactRootIndex = require('./ReactRootIndex');\n\nvar invariant = require('fbjs/lib/invariant');\n\nvar SEPARATOR = '.';\nvar SEPARATOR_LENGTH = SEPARATOR.length;\n\n/**\n * Maximum depth of traversals before we consider the possibility of a bad ID.\n */\nvar MAX_TREE_DEPTH = 10000;\n\n/**\n * Creates a DOM ID prefix to use when mounting React components.\n *\n * @param {number} index A unique integer\n * @return {string} React root ID.\n * @internal\n */\nfunction getReactRootIDString(index) {\n  return SEPARATOR + index.toString(36);\n}\n\n/**\n * Checks if a character in the supplied ID is a separator or the end.\n *\n * @param {string} id A React DOM ID.\n * @param {number} index Index of the character to check.\n * @return {boolean} True if the character is a separator or end of the ID.\n * @private\n */\nfunction isBoundary(id, index) {\n  return id.charAt(index) === SEPARATOR || index === id.length;\n}\n\n/**\n * Checks if the supplied string is a valid React DOM ID.\n *\n * @param {string} id A React DOM ID, maybe.\n * @return {boolean} True if the string is a valid React DOM ID.\n * @private\n */\nfunction isValidID(id) {\n  return id === '' || id.charAt(0) === SEPARATOR && id.charAt(id.length - 1) !== SEPARATOR;\n}\n\n/**\n * Checks if the first ID is an ancestor of or equal to the second ID.\n *\n * @param {string} ancestorID\n * @param {string} descendantID\n * @return {boolean} True if `ancestorID` is an ancestor of `descendantID`.\n * @internal\n */\nfunction isAncestorIDOf(ancestorID, descendantID) {\n  return descendantID.indexOf(ancestorID) === 0 && isBoundary(descendantID, ancestorID.length);\n}\n\n/**\n * Gets the parent ID of the supplied React DOM ID, `id`.\n *\n * @param {string} id ID of a component.\n * @return {string} ID of the parent, or an empty string.\n * @private\n */\nfunction getParentID(id) {\n  return id ? id.substr(0, id.lastIndexOf(SEPARATOR)) : '';\n}\n\n/**\n * Gets the next DOM ID on the tree path from the supplied `ancestorID` to the\n * supplied `destinationID`. If they are equal, the ID is returned.\n *\n * @param {string} ancestorID ID of an ancestor node of `destinationID`.\n * @param {string} destinationID ID of the destination node.\n * @return {string} Next ID on the path from `ancestorID` to `destinationID`.\n * @private\n */\nfunction getNextDescendantID(ancestorID, destinationID) {\n  !(isValidID(ancestorID) && isValidID(destinationID)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(%s, %s): Received an invalid React DOM ID.', ancestorID, destinationID) : invariant(false) : undefined;\n  !isAncestorIDOf(ancestorID, destinationID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getNextDescendantID(...): React has made an invalid assumption about ' + 'the DOM hierarchy. Expected `%s` to be an ancestor of `%s`.', ancestorID, destinationID) : invariant(false) : undefined;\n  if (ancestorID === destinationID) {\n    return ancestorID;\n  }\n  // Skip over the ancestor and the immediate separator. Traverse until we hit\n  // another separator or we reach the end of `destinationID`.\n  var start = ancestorID.length + SEPARATOR_LENGTH;\n  var i;\n  for (i = start; i < destinationID.length; i++) {\n    if (isBoundary(destinationID, i)) {\n      break;\n    }\n  }\n  return destinationID.substr(0, i);\n}\n\n/**\n * Gets the nearest common ancestor ID of two IDs.\n *\n * Using this ID scheme, the nearest common ancestor ID is the longest common\n * prefix of the two IDs that immediately preceded a \"marker\" in both strings.\n *\n * @param {string} oneID\n * @param {string} twoID\n * @return {string} Nearest common ancestor ID, or the empty string if none.\n * @private\n */\nfunction getFirstCommonAncestorID(oneID, twoID) {\n  var minLength = Math.min(oneID.length, twoID.length);\n  if (minLength === 0) {\n    return '';\n  }\n  var lastCommonMarkerIndex = 0;\n  // Use `<=` to traverse until the \"EOL\" of the shorter string.\n  for (var i = 0; i <= minLength; i++) {\n    if (isBoundary(oneID, i) && isBoundary(twoID, i)) {\n      lastCommonMarkerIndex = i;\n    } else if (oneID.charAt(i) !== twoID.charAt(i)) {\n      break;\n    }\n  }\n  var longestCommonID = oneID.substr(0, lastCommonMarkerIndex);\n  !isValidID(longestCommonID) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'getFirstCommonAncestorID(%s, %s): Expected a valid React DOM ID: %s', oneID, twoID, longestCommonID) : invariant(false) : undefined;\n  return longestCommonID;\n}\n\n/**\n * Traverses the parent path between two IDs (either up or down). The IDs must\n * not be the same, and there must exist a parent path between them. If the\n * callback returns `false`, traversal is stopped.\n *\n * @param {?string} start ID at which to start traversal.\n * @param {?string} stop ID at which to end traversal.\n * @param {function} cb Callback to invoke each ID with.\n * @param {*} arg Argument to invoke the callback with.\n * @param {?boolean} skipFirst Whether or not to skip the first node.\n * @param {?boolean} skipLast Whether or not to skip the last node.\n * @private\n */\nfunction traverseParentPath(start, stop, cb, arg, skipFirst, skipLast) {\n  start = start || '';\n  stop = stop || '';\n  !(start !== stop) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(...): Cannot traverse from and to the same ID, `%s`.', start) : invariant(false) : undefined;\n  var traverseUp = isAncestorIDOf(stop, start);\n  !(traverseUp || isAncestorIDOf(start, stop)) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Cannot traverse from two IDs that do ' + 'not have a parent path.', start, stop) : invariant(false) : undefined;\n  // Traverse from `start` to `stop` one depth at a time.\n  var depth = 0;\n  var traverse = traverseUp ? getParentID : getNextDescendantID;\n  for (var id = start;; /* until break */id = traverse(id, stop)) {\n    var ret;\n    if ((!skipFirst || id !== start) && (!skipLast || id !== stop)) {\n      ret = cb(id, traverseUp, arg);\n    }\n    if (ret === false || id === stop) {\n      // Only break //after// visiting `stop`.\n      break;\n    }\n    !(depth++ < MAX_TREE_DEPTH) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'traverseParentPath(%s, %s, ...): Detected an infinite loop while ' + 'traversing the React DOM ID tree. This may be due to malformed IDs: %s', start, stop, id) : invariant(false) : undefined;\n  }\n}\n\n/**\n * Manages the IDs assigned to DOM representations of React components. This\n * uses a specific scheme in order to traverse the DOM efficiently (e.g. in\n * order to simulate events).\n *\n * @internal\n */\nvar ReactInstanceHandles = {\n\n  /**\n   * Constructs a React root ID\n   * @return {string} A React root ID.\n   */\n  createReactRootID: function () {\n    return getReactRootIDString(ReactRootIndex.createReactRootIndex());\n  },\n\n  /**\n   * Constructs a React ID by joining a root ID with a name.\n   *\n   * @param {string} rootID Root ID of a parent component.\n   * @param {string} name A component's name (as flattened children).\n   * @return {string} A React ID.\n   * @internal\n   */\n  createReactID: function (rootID, name) {\n    return rootID + name;\n  },\n\n  /**\n   * Gets the DOM ID of the React component that is the root of the tree that\n   * contains the React component with the supplied DOM ID.\n   *\n   * @param {string} id DOM ID of a React component.\n   * @return {?string} DOM ID of the React component that is the root.\n   * @internal\n   */\n  getReactRootIDFromNodeID: function (id) {\n    if (id && id.charAt(0) === SEPARATOR && id.length > 1) {\n      var index = id.indexOf(SEPARATOR, 1);\n      return index > -1 ? id.substr(0, index) : id;\n    }\n    return null;\n  },\n\n  /**\n   * Traverses the ID hierarchy and invokes the supplied `cb` on any IDs that\n   * should would receive a `mouseEnter` or `mouseLeave` event.\n   *\n   * NOTE: Does not invoke the callback on the nearest common ancestor because\n   * nothing \"entered\" or \"left\" that element.\n   *\n   * @param {string} leaveID ID being left.\n   * @param {string} enterID ID being entered.\n   * @param {function} cb Callback to invoke on each entered/left ID.\n   * @param {*} upArg Argument to invoke the callback with on left IDs.\n   * @param {*} downArg Argument to invoke the callback with on entered IDs.\n   * @internal\n   */\n  traverseEnterLeave: function (leaveID, enterID, cb, upArg, downArg) {\n    var ancestorID = getFirstCommonAncestorID(leaveID, enterID);\n    if (ancestorID !== leaveID) {\n      traverseParentPath(leaveID, ancestorID, cb, upArg, false, true);\n    }\n    if (ancestorID !== enterID) {\n      traverseParentPath(ancestorID, enterID, cb, downArg, true, false);\n    }\n  },\n\n  /**\n   * Simulates the traversal of a two-phase, capture/bubble event dispatch.\n   *\n   * NOTE: This traversal happens on IDs without touching the DOM.\n   *\n   * @param {string} targetID ID of the target node.\n   * @param {function} cb Callback to invoke.\n   * @param {*} arg Argument to invoke the callback with.\n   * @internal\n   */\n  traverseTwoPhase: function (targetID, cb, arg) {\n    if (targetID) {\n      traverseParentPath('', targetID, cb, arg, true, false);\n      traverseParentPath(targetID, '', cb, arg, false, true);\n    }\n  },\n\n  /**\n   * Same as `traverseTwoPhase` but skips the `targetID`.\n   */\n  traverseTwoPhaseSkipTarget: function (targetID, cb, arg) {\n    if (targetID) {\n      traverseParentPath('', targetID, cb, arg, true, true);\n      traverseParentPath(targetID, '', cb, arg, true, true);\n    }\n  },\n\n  /**\n   * Traverse a node ID, calling the supplied `cb` for each ancestor ID. For\n   * example, passing `.0.$row-0.1` would result in `cb` getting called\n   * with `.0`, `.0.$row-0`, and `.0.$row-0.1`.\n   *\n   * NOTE: This traversal happens on IDs without touching the DOM.\n   *\n   * @param {string} targetID ID of the target node.\n   * @param {function} cb Callback to invoke.\n   * @param {*} arg Argument to invoke the callback with.\n   * @internal\n   */\n  traverseAncestors: function (targetID, cb, arg) {\n    traverseParentPath('', targetID, cb, arg, true, false);\n  },\n\n  getFirstCommonAncestorID: getFirstCommonAncestorID,\n\n  /**\n   * Exposed for unit testing.\n   * @private\n   */\n  _getNextDescendantID: getNextDescendantID,\n\n  isAncestorIDOf: isAncestorIDOf,\n\n  SEPARATOR: SEPARATOR\n\n};\n\nmodule.exports = ReactInstanceHandles;\n};"],
"names":["shadow$provide","global","require","module","exports","isBoundary","id","index","SEPARATOR","charAt","length","isValidID","isAncestorIDOf","ancestorID","descendantID","indexOf","getParentID","substr","lastIndexOf","getNextDescendantID","destinationID","undefined","invariant","i","getFirstCommonAncestorID","oneID","twoID","minLength","Math","min","lastCommonMarkerIndex","longestCommonID","traverseParentPath","start","stop","cb","arg","skipFirst","skipLast","traverseUp","depth","traverse","ret","MAX_TREE_DEPTH","ReactRootIndex","ReactInstanceHandles","createReactRootID","createReactRootIndex","toString","createReactID","rootID","name","getReactRootIDFromNodeID","traverseEnterLeave","leaveID","enterID","upArg","downArg","traverseTwoPhase","targetID","traverseTwoPhaseSkipTarget","traverseAncestors","_getNextDescendantID"]
}
