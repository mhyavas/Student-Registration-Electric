{"version":3,"sources":["contrib/trace.cljc"],"mappings":";AASA,AAEA,AACA,AACA,AACA,AAuBA,8BAAA,9BAAOA,oEAAeC;AAAtB,AACE;;6BACIC;AADJ,AACc,IAAAC,WAAA,mFAAA,uDAAaD;AAAb,AAAA,8EAAAC,0BAAAA,hGAACF,oCAAAA,8CAAAA;;6BACXG,GAAGC;AAFP,AAEc,IAAAC,WAAA,mFAAA,wDAAaF,GAAGC;AAAhB,AAAA,8EAAAC,0BAAAA,hGAACL,oCAAAA,8CAAAA;;oBAAXG,GAAGC;;;6BAAHD;;6BAAAA,GAAGC;;;;;;;;;AAET,AAsBA,0BAAA,1BAAME;AAAN,AAAmB,IAAMC,UAAG,6CAAA,7CAACC;AAAV,AAAmB,kBAAKC;AAAL,AAAQ,OAACC,mDAAMH,QAAGI;;;AAExD,AASA","names":["contrib.trace/test-listener","tap","point","G__35821","id","trace","G__35822","contrib.trace/monotonic","!t","cljs.core.atom","_","cljs.core.swap_BANG_","cljs.core/inc"],"sourcesContent":["(ns contrib.trace\n  (:require\n   [hyperfiddle.electric :as e]\n   [hyperfiddle.rcf :as rcf :refer [% tap tests with]])\n  (:import\n   [hyperfiddle.electric Pending]\n   [missionary Cancelled])\n  #?(:cljs (:require-macros contrib.trace)))\n\n(e/def listeners '())\n(defmacro with-listener [l & body] `(binding [listeners (conj listeners ~l)] ~@body))\n(e/def stamp (fn [_]))\n(e/def ->point-id (fn [_name _parent-id]))\n(e/def ->trace-id (fn [_point-id _v]))\n(e/def current nil)\n\n;; https://github.com/cgrand/macrovich/blob/e80fb37cb795201821d0e75f73119802227e9620/src/net/cgrand/macrovich.cljc\n(defmacro macro-case [& {:keys [cljs clj]}]\n  (if (contains? &env '&env)\n    `(if (:ns ~'&env) ~cljs ~clj)\n    (if #?(:clj (:ns &env) :cljs true) cljs clj)))\n\n(defmacro trace [nm & body]\n  `(let [nm# ~nm, id# (->point-id nm# (or current 0)), point# {::point-id id#, ::name nm#, ::parent (or current ::root)}]\n     (doseq [l# listeners] (l# point#))\n     (let [[typ# v#] (binding [current id#]\n                       (try [::ok (do ~@body)]\n                            (catch ~(macro-case :clj Throwable :cljs :default) e# [::err e#])))\n           trace-id# (->trace-id id# v#)\n           stamp# (stamp v#)\n           ;; TODO put exception in trace map\n           tr# {::trace-id trace-id#, ::stamp stamp#, ::type typ#, ::v v#}]\n       (doseq [l# listeners] (l# id# tr#))\n       (case typ# ::ok v# #_else (throw v#)))))\n\n(defmacro trace* [nm & body] `(when current (trace ~nm ~@body)))\n\n(defn- test-listener [tap]\n  (fn\n    ([point]    (tap [:point point]))\n    ([id trace] (tap [:trace id trace]))))\n\n(tests \"basic behavior\"\n  (with (e/run (try (binding [->point-id #(do (tap [:point-id % %2]) %)\n                              stamp (let [!t (atom 0)] (fn [_] (let [t (swap! !t inc)] (tap [:stamp]) t)))\n                              ->trace-id (fn [id v] (tap [:trace-id id v]) (str (name id) \"-1\"))]\n                      (with-listener (test-listener tap)\n                        (tap (trace :outer\n                               (trace :inner 0 1)))))\n                    (catch Pending _)\n                    (catch Cancelled _)\n                    (catch #?(:clj Throwable :cljs :default) e (prn :error (ex-message e)) (throw e))))\n    % := [:point-id :outer 0]\n    % := [:point {::point-id :outer, ::name :outer, ::parent ::root}]\n    % := [:point-id :inner :outer]\n    % := [:point {::point-id :inner, ::name :inner, ::parent :outer}]\n    % := [:trace-id :inner 1]\n    % := [:stamp]\n    % := [:trace :inner {::trace-id \"inner-1\", ::stamp 1, ::v 1, ::type ::ok}]\n    % := [:trace-id :outer 1]\n    % := [:stamp]\n    % := [:trace :outer {::trace-id \"outer-1\" ::stamp 2, ::v 1, ::type ::ok}]\n    % := 1))\n\n(defn monotonic [] (let [!t (atom 0)] (fn [_] (swap! !t inc))))\n\n(tests \"exceptions\"\n  (with (e/run (try (binding [->point-id (fn [nm _parent] nm), stamp (monotonic), ->trace-id (fn [id _v] (str (name id) \"-1\"))]\n                      (with-listener (test-listener tap)\n                        (tap (trace :x (throw (ex-info \"boom\" {}))))))\n                    (catch #?(:clj Throwable :cljs :default) e\n                      (when-not (= \"boom\" (ex-message e)) (prn [(type e) (ex-message e)])))))\n    % := [:point {::point-id :x, ::name :x, ::parent ::root}]\n    % := [:trace :x {::trace-id \"x-1\" , ::stamp 1, ::v _, ::type ::err}]))\n\n(tests \"works across e/fn boundaries\"\n  (with (e/run (try (binding [->point-id (fn [nm _parent] nm), stamp (monotonic), ->trace-id (fn [id _v] (str (name id) \"-1\"))]\n                      (with-listener (test-listener tap)\n                        (trace :outer\n                          (new (e/fn [] (trace :inner 1))))))\n                    (catch Pending _)\n                    (catch Cancelled _)\n                    (catch #?(:clj Throwable :cljs :default) e (prn :error (ex-message e)) (throw e))))\n    % := [:point _]\n    % := [:point _]\n    % := [:trace :inner {::trace-id \"inner-1\" ::stamp 1, ::v 1, ::type ::ok}]\n    % := [:trace :outer {::trace-id \"outer-1\", ::stamp 2, ::v 1, ::type ::ok}]))\n"]}