{
"version":3,
"file":"module$node_modules$react_offcanvas$node_modules$react$lib$ReactUpdates.js",
"lineCount":10,
"mappings":"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",
"sources":["node_modules/react-offcanvas/node_modules/react/lib/ReactUpdates.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$react_offcanvas$node_modules$react$lib$ReactUpdates\"] = function(global,require,module,exports) {\n/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdates\n */\n\n'use strict';\n\nvar CallbackQueue = require('./CallbackQueue');\nvar PooledClass = require('./PooledClass');\nvar ReactPerf = require('./ReactPerf');\nvar ReactReconciler = require('./ReactReconciler');\nvar Transaction = require('./Transaction');\n\nvar assign = require('./Object.assign');\nvar invariant = require('fbjs/lib/invariant');\n\nvar dirtyComponents = [];\nvar asapCallbackQueue = CallbackQueue.getPooled();\nvar asapEnqueued = false;\n\nvar batchingStrategy = null;\n\nfunction ensureInjected() {\n  !(ReactUpdates.ReactReconcileTransaction && batchingStrategy) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must inject a reconcile transaction class and batching ' + 'strategy') : invariant(false) : undefined;\n}\n\nvar NESTED_UPDATES = {\n  initialize: function () {\n    this.dirtyComponentsLength = dirtyComponents.length;\n  },\n  close: function () {\n    if (this.dirtyComponentsLength !== dirtyComponents.length) {\n      // Additional updates were enqueued by componentDidUpdate handlers or\n      // similar; before our own UPDATE_QUEUEING wrapper closes, we want to run\n      // these new updates so that if A's componentDidUpdate calls setState on\n      // B, B will update before the callback A's updater provided when calling\n      // setState.\n      dirtyComponents.splice(0, this.dirtyComponentsLength);\n      flushBatchedUpdates();\n    } else {\n      dirtyComponents.length = 0;\n    }\n  }\n};\n\nvar UPDATE_QUEUEING = {\n  initialize: function () {\n    this.callbackQueue.reset();\n  },\n  close: function () {\n    this.callbackQueue.notifyAll();\n  }\n};\n\nvar TRANSACTION_WRAPPERS = [NESTED_UPDATES, UPDATE_QUEUEING];\n\nfunction ReactUpdatesFlushTransaction() {\n  this.reinitializeTransaction();\n  this.dirtyComponentsLength = null;\n  this.callbackQueue = CallbackQueue.getPooled();\n  this.reconcileTransaction = ReactUpdates.ReactReconcileTransaction.getPooled( /* forceHTML */false);\n}\n\nassign(ReactUpdatesFlushTransaction.prototype, Transaction.Mixin, {\n  getTransactionWrappers: function () {\n    return TRANSACTION_WRAPPERS;\n  },\n\n  destructor: function () {\n    this.dirtyComponentsLength = null;\n    CallbackQueue.release(this.callbackQueue);\n    this.callbackQueue = null;\n    ReactUpdates.ReactReconcileTransaction.release(this.reconcileTransaction);\n    this.reconcileTransaction = null;\n  },\n\n  perform: function (method, scope, a) {\n    // Essentially calls `this.reconcileTransaction.perform(method, scope, a)`\n    // with this transaction's wrappers around it.\n    return Transaction.Mixin.perform.call(this, this.reconcileTransaction.perform, this.reconcileTransaction, method, scope, a);\n  }\n});\n\nPooledClass.addPoolingTo(ReactUpdatesFlushTransaction);\n\nfunction batchedUpdates(callback, a, b, c, d, e) {\n  ensureInjected();\n  batchingStrategy.batchedUpdates(callback, a, b, c, d, e);\n}\n\n/**\n * Array comparator for ReactComponents by mount ordering.\n *\n * @param {ReactComponent} c1 first component you're comparing\n * @param {ReactComponent} c2 second component you're comparing\n * @return {number} Return value usable by Array.prototype.sort().\n */\nfunction mountOrderComparator(c1, c2) {\n  return c1._mountOrder - c2._mountOrder;\n}\n\nfunction runBatchedUpdates(transaction) {\n  var len = transaction.dirtyComponentsLength;\n  !(len === dirtyComponents.length) ? process.env.NODE_ENV !== 'production' ? invariant(false, 'Expected flush transaction\\'s stored dirty-components length (%s) to ' + 'match dirty-components array length (%s).', len, dirtyComponents.length) : invariant(false) : undefined;\n\n  // Since reconciling a component higher in the owner hierarchy usually (not\n  // always -- see shouldComponentUpdate()) will reconcile children, reconcile\n  // them before their children by sorting the array.\n  dirtyComponents.sort(mountOrderComparator);\n\n  for (var i = 0; i < len; i++) {\n    // If a component is unmounted before pending changes apply, it will still\n    // be here, but we assume that it has cleared its _pendingCallbacks and\n    // that performUpdateIfNecessary is a noop.\n    var component = dirtyComponents[i];\n\n    // If performUpdateIfNecessary happens to enqueue any new updates, we\n    // shouldn't execute the callbacks until the next render happens, so\n    // stash the callbacks first\n    var callbacks = component._pendingCallbacks;\n    component._pendingCallbacks = null;\n\n    ReactReconciler.performUpdateIfNecessary(component, transaction.reconcileTransaction);\n\n    if (callbacks) {\n      for (var j = 0; j < callbacks.length; j++) {\n        transaction.callbackQueue.enqueue(callbacks[j], component.getPublicInstance());\n      }\n    }\n  }\n}\n\nvar flushBatchedUpdates = function () {\n  // ReactUpdatesFlushTransaction's wrappers will clear the dirtyComponents\n  // array and perform any updates enqueued by mount-ready handlers (i.e.,\n  // componentDidUpdate) but we need to check here too in order to catch\n  // updates enqueued by setState callbacks and asap calls.\n  while (dirtyComponents.length || asapEnqueued) {\n    if (dirtyComponents.length) {\n      var transaction = ReactUpdatesFlushTransaction.getPooled();\n      transaction.perform(runBatchedUpdates, null, transaction);\n      ReactUpdatesFlushTransaction.release(transaction);\n    }\n\n    if (asapEnqueued) {\n      asapEnqueued = false;\n      var queue = asapCallbackQueue;\n      asapCallbackQueue = CallbackQueue.getPooled();\n      queue.notifyAll();\n      CallbackQueue.release(queue);\n    }\n  }\n};\nflushBatchedUpdates = ReactPerf.measure('ReactUpdates', 'flushBatchedUpdates', flushBatchedUpdates);\n\n/**\n * Mark a component as needing a rerender, adding an optional callback to a\n * list of functions which will be executed once the rerender occurs.\n */\nfunction enqueueUpdate(component) {\n  ensureInjected();\n\n  // Various parts of our code (such as ReactCompositeComponent's\n  // _renderValidatedComponent) assume that calls to render aren't nested;\n  // verify that that's the case. (This is called by each top-level update\n  // function, like setProps, setState, forceUpdate, etc.; creation and\n  // destruction of top-level components is guarded in ReactMount.)\n\n  if (!batchingStrategy.isBatchingUpdates) {\n    batchingStrategy.batchedUpdates(enqueueUpdate, component);\n    return;\n  }\n\n  dirtyComponents.push(component);\n}\n\n/**\n * Enqueue a callback to be run at the end of the current batching cycle. Throws\n * if no updates are currently being performed.\n */\nfunction asap(callback, context) {\n  !batchingStrategy.isBatchingUpdates ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates.asap: Can\\'t enqueue an asap callback in a context where' + 'updates are not being batched.') : invariant(false) : undefined;\n  asapCallbackQueue.enqueue(callback, context);\n  asapEnqueued = true;\n}\n\nvar ReactUpdatesInjection = {\n  injectReconcileTransaction: function (ReconcileTransaction) {\n    !ReconcileTransaction ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a reconcile transaction class') : invariant(false) : undefined;\n    ReactUpdates.ReactReconcileTransaction = ReconcileTransaction;\n  },\n\n  injectBatchingStrategy: function (_batchingStrategy) {\n    !_batchingStrategy ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batching strategy') : invariant(false) : undefined;\n    !(typeof _batchingStrategy.batchedUpdates === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide a batchedUpdates() function') : invariant(false) : undefined;\n    !(typeof _batchingStrategy.isBatchingUpdates === 'boolean') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'ReactUpdates: must provide an isBatchingUpdates boolean attribute') : invariant(false) : undefined;\n    batchingStrategy = _batchingStrategy;\n  }\n};\n\nvar ReactUpdates = {\n  /**\n   * React references `ReactReconcileTransaction` using this property in order\n   * to allow dependency injection.\n   *\n   * @internal\n   */\n  ReactReconcileTransaction: null,\n\n  batchedUpdates: batchedUpdates,\n  enqueueUpdate: enqueueUpdate,\n  flushBatchedUpdates: flushBatchedUpdates,\n  injection: ReactUpdatesInjection,\n  asap: asap\n};\n\nmodule.exports = ReactUpdates;\n};"],
"names":["shadow$provide","global","require","module","exports","ensureInjected","ReactUpdates","ReactReconcileTransaction","batchingStrategy","undefined","invariant","ReactUpdatesFlushTransaction","reinitializeTransaction","dirtyComponentsLength","callbackQueue","CallbackQueue","getPooled","reconcileTransaction","mountOrderComparator","c1","c2","_mountOrder","runBatchedUpdates","transaction","len","dirtyComponents","length","sort","i","component","callbacks","_pendingCallbacks","ReactReconciler","performUpdateIfNecessary","j","enqueue","getPublicInstance","enqueueUpdate","isBatchingUpdates","push","batchedUpdates","PooledClass","ReactPerf","Transaction","assign","asapCallbackQueue","asapEnqueued","TRANSACTION_WRAPPERS","NESTED_UPDATES","initialize","close","splice","flushBatchedUpdates","UPDATE_QUEUEING","reset","notifyAll","prototype","Mixin","getTransactionWrappers","destructor","release","perform","method","scope","a","call","addPoolingTo","queue","measure","callback","b","c","d","e","injection","ReactUpdatesInjection","injectReconcileTransaction","ReconcileTransaction","injectBatchingStrategy","_batchingStrategy","asap","context"]
}
