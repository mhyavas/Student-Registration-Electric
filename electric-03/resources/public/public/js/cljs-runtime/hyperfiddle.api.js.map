{"version":3,"sources":["hyperfiddle/api.cljc"],"mappings":";;;;AAUA,AACA,AACA,AAAAA,yBAAA,AAAA,kFAAA,AAAA,2EAAcC;AACd,AACA,AACA,AACA,AAAKC,wCAAsB,wEAAA,2CAAA,4DAAA,2CAAA,AAAA,1NAACC,gDAAQC,mPACoCC;AAExE,AACA,AAIA,AACA,AAEA,AACA,AACA,AAOA,yBAAA,zBAAMC,0DAAQC;AAAd,AAAmB,IAAAC,mBAAI,AAAA,oHAAUD;AAAd,AAAA,oBAAAC;AAAAA;;AAAmB,OAAA,oHAAU,AAAA,oHAAUD;;;AAC1D,4BAAA,5BAAME,gEAAWF;AAAjB,AAAsB,IAAAC,mBAAI,AAAA,yHAAaD;AAAjB,AAAA,oBAAAC;AAAAA;;AAAsB,OAAA,yHAAa,AAAA,oHAAUD;;;AAEnE,AAEA,AASA,GAAA,QAAAG,wCAAAC,4CAAAC;AAAA;AAAA,AAAA,0BAAA,iBAAAC,6BAAA,AAAAC,6CAAA,rHAAUS;IAAVR,6BAAA,AAAAD,6CAAA;IAAAE,6BAAA,AAAAF,6CAAA;IAAAG,iCAAA,AAAAH,6CAAA;IAAAI,0BAAA,AAAAC,4CAAA,mCAAA,gEAAA,iBAAAC,eAAA;AAAA,AAAA,QAAAA,6CAAAA,+CAAAA;;AAAA,AAAA,YAAAC,kBAAA,AAAAC,+CAAA,kBAAA,WAAkB,WAAKE,OAAOC;AAAZ,AAAgB,GAAI,AAACC,qBAAKD;AAAV;;AAAoB,OAACE,gBAAMF;;GAA7D,4DAAAP,wBAAAL,2BAAAE,2BAAAC,2BAAAC;;;AAEA,AAAAjB,yBAAA,AAAA,sGAAA,AAAA,yMAAwB,AAAA4B,6BAAA,mFAAA,0DAAA,AAAA,gJAAA,mFAAA,6DAAA;AACxB,AAAA5B,yBAAA,AAAA,mGAAA,AAAA,2EAAuB0B;AACvB,AAAA1B,yBAAA,AAAA,6FAAA,AAAA,sEAAoB6B;AACpB,AAAA7B,yBAAA,AAAA,6FAAA,AAAA,sEAAoB6B;AACpB,AAAA7B,yBAAA,AAAA,yGAAA,AAAA,62BAA0B,AAAA8B,8BAAA,wCAAA,yDAAA,wDAAA,kDAAA,iEAAA,8DAAA,6DAAA,8DAAA,mDAAA,4DAAA,+DAAA,gEAAA,qDAAA,AAAA,KAAA,AAAA,KAAA,KAAA,mFAAA,WAAAC;AAAA,AAAA,OAAAL,qBAAAK;GAAA,WAAAA;AAAA,AAAA,OAAAC,0BAAAD,SAAA;WAAA,WAAAA;AAAA,AAAA,SAAA,AAAAL,qBAAAK,eAAA,AAAAC,0BAAAD,SAAA;GAAA,AAAA,meAAA,AAAA,8LAAA,AAAA,8LAAA,AAAA,8LAAA,AAAA,meAAA,AAAA,66BAAA,AAAA;AAG1B,AAAA/B,yBAAA,AAAA,6FAAA,AAAA,qQAAA,AAAAiC,2BAAA,KAAA,AAAA,KAAA,AAAAC,wDAAA,AAAA,yGAAA,yGAAA,KAAA,MAAA,AAAA,yGAAA,KAAA,AAAA,KAAA;AAcA,AAYA,AACA,AACA,AACA,AAEA,AASA,AA4BA,AACA,AAEA","names":["cljs.spec.alpha/def-impl","cljs.core/any?","hyperfiddle.api/-read-edn-str-default","cljs.core.partial","clojure.edn/read-string","hyperfiddle.api.goog$module$goog$math$Long.fromString","hyperfiddle.api/entity","ctx","or__5045__auto__","hyperfiddle.api/attribute","js/hyperfiddle","js/hyperfiddle.api","js/hyperfiddle.api.tx-meta","method-table__5642__auto__","cljs.core.atom","prefer-table__5643__auto__","method-cache__5644__auto__","cached-hierarchy__5645__auto__","hierarchy__5646__auto__","cljs.core.get","fexpr__48974","cljs.core/MultiFn","cljs.core.symbol","hyperfiddle.api/tx-meta","schema","tx","cljs.core/map?","cljs.core/first","cljs.spec.alpha/or-spec-impl","cljs.core/fn?","cljs.spec.alpha/map-spec-impl","G__48986","cljs.core/contains?","cljs.spec.alpha/fspec-impl","cljs.spec.alpha.spec_impl"],"sourcesContent":["(ns hyperfiddle.api\r\n  (:import [hyperfiddle.electric Pending]\r\n           #?(:cljs [goog.math Long]))\r\n  (:require clojure.edn\r\n            [contrib.dynamic :refer [call-sym]]\r\n            [clojure.spec.alpha :as s]\r\n            [hyperfiddle.electric :as e]\r\n            [missionary.core :as m]\r\n            hyperfiddle.electric-dom2))\r\n\r\n(def ^:dynamic *$*) ; dbval, for REPL usage. Available in cljs for HFQL datascript tests\r\n(e/def db \"inject database value for hyperfiddle stage and HFQL\")\r\n(s/def ::ref? any?)\r\n(e/def secure-db \"database value excluding stage, so that user can't tamper\")\r\n(e/def with \"inject datomic.api/with or equivalent, used by stage\")\r\n(e/def into-tx')\r\n(def -read-edn-str-default (partial clojure.edn/read-string\r\n                                    {:readers #?(:cljs {'goog.math/Long goog.math.Long/fromString} ; datomic cloud long ids\r\n                                                :clj {})}))\r\n(e/def read-edn-str \"inject app-specific edn extensions\" -read-edn-str-default) ; avoid Electric warning about goog.math.Long\r\n(e/def ^:dynamic *nav!*)\r\n\r\n;;; Database\r\n\r\n(def db-state #?(:clj (atom nil))) ; Server side only\r\n(e/def db-name \"$\")\r\n\r\n(e/def schema \"pre-fetched schema for explorer\")\r\n(e/def ^{:dynamic true, :doc \"To be bound to a function [db attribute] -> schema\"} *schema*)\r\n(e/def ^{:dynamic true, :doc \"To be bound to a function schema -> ::hf/one | ::hf/many\"} *cardinality*\r\n  (fn cardinality [schemaf db attr]\r\n    (let [card\r\n          ({:db.cardinality/one ::one\r\n            :db.cardinality/many ::many} (:db/cardinality (schemaf db attr)))]\r\n      card)))\r\n\r\n(defn entity [ctx] (or (::entity ctx) (::entity (::parent ctx))))\r\n(defn attribute [ctx] (or (::attribute ctx) (::attribute (::parent ctx))))\r\n\r\n(e/def validation-hints nil)\r\n\r\n(e/defn tx \"WIP, this default impl captures the essence\" [v' props] ; meant to be called by a renderer\r\n  ;; Does it return a tx or side-effect to the staging area?\r\n  (assert false \"TBD\")\r\n  #_(if-let [Txfn (::tx props)] ; provided by hfql (props ... {::hf/tx (p/fn [] ...)})\r\n      (Txfn. v')\r\n      (when v'\r\n        (let [[E a _] (first context)] ; context is a stack of [[E a] ...] in dynamic scope ; MISSING today\r\n          [[:db/add (E.) a v']]))))\r\n\r\n(defmulti tx-meta (fn [schema tx] (if (map? tx) ::map (first tx))))\r\n\r\n(s/def ::tx-cardinality (s/or :one :many))\r\n(s/def ::tx-identifier map?)\r\n(s/def ::tx-inverse fn?)\r\n(s/def ::tx-special fn?)\r\n(s/def ::transaction-meta (s/keys :req [::tx-identifier]\r\n                                  :opt [::tx-cardinality ::tx-inverse ::tx-special\r\n                                        ::tx-conflicting?]))\r\n(s/fdef tx-meta :ret ::transaction-meta)\r\n\r\n; resolve cycle - hyperfiddle.txn needs hf/tx-meta\r\n#?(:clj (require 'hyperfiddle.txn)) ; [rosie] before rcf turns on due to test/seattle undefined\r\n#?(:clj (defn expand-hf-tx [tx] (call-sym 'hyperfiddle.txn/expand-hf-tx tx)))\r\n;#?(:clj\r\n;   (defmacro into-tx\r\n;     ([tx tx'] `(call-sym ~'hyperfiddle.txn/into-tx ~hyperfiddle.api/schema ~tx ~tx')) ; Electric call can infer schema\r\n;     ([schema tx tx'] `(call-sym ~'hyperfiddle.txn/into-tx ~schema ~tx ~tx'))) ; clojure compatible call\r\n;   :cljs (def into-tx nil))\r\n#?(:clj (defn into-tx\r\n          ;([tx tx'] (into-tx schema tx tx')) -- needs Electric->Clojure binding conveyance\r\n          ([schema tx tx'] (call-sym 'hyperfiddle.txn/into-tx schema tx tx'))))\r\n\r\n(e/defn Transact!* [!t tx] ; colorless, !t on server\r\n  ; need the flattening be atomic?\r\n  #_(when-some [tx (seq (hyperfiddle.txn/minimal-tx hyperfiddle.api/db tx))]) ; stabilize first loop (optional)\r\n  (new (e/task->cp\r\n         ;; workaround: Datomic doesn't handle a thread interrupt correctly\r\n         (m/compel\r\n           (m/via m/blk\r\n             ;; return basis-t ?\r\n             (swap! !t (fn [[db tx0]]\r\n                         [(with db tx) ; injected datomic dep\r\n                          (into-tx' schema tx0 tx)]))))))) ; datascript is different\r\n\r\n(e/def Transact!) ; server\r\n(e/def ClearStage!) ; server\r\n(e/def stage) ; server\r\n(e/def loading) ; client\r\n\r\n(e/defn Load-timer []\r\n  (e/client\r\n    (let [[x] (e/with-cycle [[elapsed start :as s] [0 nil]]\r\n                (case hyperfiddle.api/loading\r\n                  true [(some->> start (- e/system-time-ms))\r\n                             (js/Date.now)]\r\n                  s))]\r\n      x)))\r\n\r\n(e/defn Branch [Body-server] ; todo colorless\r\n  (e/server\r\n    (let [!ret (atom nil)\r\n          parent-db db\r\n          !t (atom #_::unknown [db []]) ; broken in multiplayer\r\n          [db stage] (e/watch !t)]\r\n      (binding [hyperfiddle.api/db db\r\n                hyperfiddle.api/stage stage\r\n                hyperfiddle.api/Transact! (e/fn [tx]\r\n                                            #_(println \"Transact! \" (hash !t) \"committing: \" tx)\r\n                                            (let [r (Transact!*. !t tx)]\r\n                                              #_(println \"Transact! \" (hash !t) \"commit result: \" r)))\r\n                hyperfiddle.api/ClearStage! (e/fn [] (reset! !t [parent-db []]) nil)]\r\n        (e/client\r\n          (e/with-cycle [loading false]\r\n            (binding [hyperfiddle.api/loading loading]\r\n              #_(dom/div (name loading) \" \" (str (Load-timer.)) \"ms\")\r\n              (try\r\n                (e/server\r\n                  (let [x (Body-server.)] ; cycle x?\r\n                    #_(println 'Branch x)\r\n                    (reset! !ret x))) ; if the body returns something, return it. (Likely not used)\r\n                false (catch Pending e true))))\r\n          nil))\r\n      (e/watch !ret)))) ; do we need this? Popover using it currently\r\n\r\n(defmacro branch [& body] `(new Branch (e/fn [] ~@body)))\r\n\r\n(e/def page-drop -1)\r\n(e/def page-take -1)\r\n\r\n(e/defn Paginate [xs]\r\n  (if (coll? xs)\r\n    (cond->> xs\r\n      (pos-int? page-drop) (drop page-drop)\r\n      (pos-int? page-take) (take page-take))\r\n    xs))\r\n"]}