{
"version":3,
"file":"module$node_modules$react_offcanvas$node_modules$react$lib$ReactUpdateQueue.js",
"lineCount":11,
"mappings":"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",
"sources":["node_modules/react-offcanvas/node_modules/react/lib/ReactUpdateQueue.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$react_offcanvas$node_modules$react$lib$ReactUpdateQueue\"] = function(global,require,module,exports) {\n/**\n * Copyright 2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule ReactUpdateQueue\n */\n\n'use strict';\n\nvar ReactCurrentOwner = require('./ReactCurrentOwner');\nvar ReactElement = require('./ReactElement');\nvar ReactInstanceMap = require('./ReactInstanceMap');\nvar ReactUpdates = require('./ReactUpdates');\n\nvar assign = require('./Object.assign');\nvar invariant = require('fbjs/lib/invariant');\nvar warning = require('fbjs/lib/warning');\n\nfunction enqueueUpdate(internalInstance) {\n  ReactUpdates.enqueueUpdate(internalInstance);\n}\n\nfunction getInternalInstanceReadyForUpdate(publicInstance, callerName) {\n  var internalInstance = ReactInstanceMap.get(publicInstance);\n  if (!internalInstance) {\n    if (process.env.NODE_ENV !== 'production') {\n      // Only warn when we have a callerName. Otherwise we should be silent.\n      // We're probably calling from enqueueCallback. We don't want to warn\n      // there because we already warned for the corresponding lifecycle method.\n      process.env.NODE_ENV !== 'production' ? warning(!callerName, '%s(...): Can only update a mounted or mounting component. ' + 'This usually means you called %s() on an unmounted component. ' + 'This is a no-op. Please check the code for the %s component.', callerName, callerName, publicInstance.constructor.displayName) : undefined;\n    }\n    return null;\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(ReactCurrentOwner.current == null, '%s(...): Cannot update during an existing state transition ' + '(such as within `render`). Render methods should be a pure function ' + 'of props and state.', callerName) : undefined;\n  }\n\n  return internalInstance;\n}\n\n/**\n * ReactUpdateQueue allows for state updates to be scheduled into a later\n * reconciliation step.\n */\nvar ReactUpdateQueue = {\n\n  /**\n   * Checks whether or not this composite component is mounted.\n   * @param {ReactClass} publicInstance The instance we want to test.\n   * @return {boolean} True if mounted, false otherwise.\n   * @protected\n   * @final\n   */\n  isMounted: function (publicInstance) {\n    if (process.env.NODE_ENV !== 'production') {\n      var owner = ReactCurrentOwner.current;\n      if (owner !== null) {\n        process.env.NODE_ENV !== 'production' ? warning(owner._warnedAboutRefsInRender, '%s is accessing isMounted inside its render() function. ' + 'render() should be a pure function of props and state. It should ' + 'never access something that requires stale data from the previous ' + 'render, such as refs. Move this logic to componentDidMount and ' + 'componentDidUpdate instead.', owner.getName() || 'A component') : undefined;\n        owner._warnedAboutRefsInRender = true;\n      }\n    }\n    var internalInstance = ReactInstanceMap.get(publicInstance);\n    if (internalInstance) {\n      // During componentWillMount and render this will still be null but after\n      // that will always render to something. At least for now. So we can use\n      // this hack.\n      return !!internalInstance._renderedComponent;\n    } else {\n      return false;\n    }\n  },\n\n  /**\n   * Enqueue a callback that will be executed after all the pending updates\n   * have processed.\n   *\n   * @param {ReactClass} publicInstance The instance to use as `this` context.\n   * @param {?function} callback Called after state is updated.\n   * @internal\n   */\n  enqueueCallback: function (publicInstance, callback) {\n    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\\'t callable.') : invariant(false) : undefined;\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance);\n\n    // Previously we would throw an error if we didn't have an internal\n    // instance. Since we want to make it a no-op instead, we mirror the same\n    // behavior we have in other enqueue* methods.\n    // We also need to ignore callbacks in componentWillMount. See\n    // enqueueUpdates.\n    if (!internalInstance) {\n      return null;\n    }\n\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    // TODO: The callback here is ignored when setState is called from\n    // componentWillMount. Either fix it or disallow doing so completely in\n    // favor of getInitialState. Alternatively, we can disallow\n    // componentWillMount during server-side rendering.\n    enqueueUpdate(internalInstance);\n  },\n\n  enqueueCallbackInternal: function (internalInstance, callback) {\n    !(typeof callback === 'function') ? process.env.NODE_ENV !== 'production' ? invariant(false, 'enqueueCallback(...): You called `setProps`, `replaceProps`, ' + '`setState`, `replaceState`, or `forceUpdate` with a callback that ' + 'isn\\'t callable.') : invariant(false) : undefined;\n    if (internalInstance._pendingCallbacks) {\n      internalInstance._pendingCallbacks.push(callback);\n    } else {\n      internalInstance._pendingCallbacks = [callback];\n    }\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Forces an update. This should only be invoked when it is known with\n   * certainty that we are **not** in a DOM transaction.\n   *\n   * You may want to call this when you know that some deeper aspect of the\n   * component's state has changed but `setState` was not called.\n   *\n   * This will not invoke `shouldComponentUpdate`, but it will invoke\n   * `componentWillUpdate` and `componentDidUpdate`.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @internal\n   */\n  enqueueForceUpdate: function (publicInstance) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'forceUpdate');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingForceUpdate = true;\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Replaces all of the state. Always use this or `setState` to mutate state.\n   * You should treat `this.state` as immutable.\n   *\n   * There is no guarantee that `this.state` will be immediately updated, so\n   * accessing `this.state` after calling this method may return the old value.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} completeState Next state.\n   * @internal\n   */\n  enqueueReplaceState: function (publicInstance, completeState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceState');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    internalInstance._pendingStateQueue = [completeState];\n    internalInstance._pendingReplaceState = true;\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the state. This only exists because _pendingState is\n   * internal. This provides a merging strategy that is not available to deep\n   * properties which is confusing. TODO: Expose pendingState or don't use it\n   * during the merge.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialState Next partial state to be merged with state.\n   * @internal\n   */\n  enqueueSetState: function (publicInstance, partialState) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setState');\n\n    if (!internalInstance) {\n      return;\n    }\n\n    var queue = internalInstance._pendingStateQueue || (internalInstance._pendingStateQueue = []);\n    queue.push(partialState);\n\n    enqueueUpdate(internalInstance);\n  },\n\n  /**\n   * Sets a subset of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} partialProps Subset of the next props.\n   * @internal\n   */\n  enqueueSetProps: function (publicInstance, partialProps) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'setProps');\n    if (!internalInstance) {\n      return;\n    }\n    ReactUpdateQueue.enqueueSetPropsInternal(internalInstance, partialProps);\n  },\n\n  enqueueSetPropsInternal: function (internalInstance, partialProps) {\n    var topLevelWrapper = internalInstance._topLevelWrapper;\n    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'setProps(...): You called `setProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;\n\n    // Merge with the pending element if it exists, otherwise with existing\n    // element props.\n    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;\n    var element = wrapElement.props;\n    var props = assign({}, element.props, partialProps);\n    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));\n\n    enqueueUpdate(topLevelWrapper);\n  },\n\n  /**\n   * Replaces all of the props.\n   *\n   * @param {ReactClass} publicInstance The instance that should rerender.\n   * @param {object} props New props.\n   * @internal\n   */\n  enqueueReplaceProps: function (publicInstance, props) {\n    var internalInstance = getInternalInstanceReadyForUpdate(publicInstance, 'replaceProps');\n    if (!internalInstance) {\n      return;\n    }\n    ReactUpdateQueue.enqueueReplacePropsInternal(internalInstance, props);\n  },\n\n  enqueueReplacePropsInternal: function (internalInstance, props) {\n    var topLevelWrapper = internalInstance._topLevelWrapper;\n    !topLevelWrapper ? process.env.NODE_ENV !== 'production' ? invariant(false, 'replaceProps(...): You called `replaceProps` on a ' + 'component with a parent. This is an anti-pattern since props will ' + 'get reactively updated when rendered. Instead, change the owner\\'s ' + '`render` method to pass the correct value as props to the component ' + 'where it is created.') : invariant(false) : undefined;\n\n    // Merge with the pending element if it exists, otherwise with existing\n    // element props.\n    var wrapElement = topLevelWrapper._pendingElement || topLevelWrapper._currentElement;\n    var element = wrapElement.props;\n    topLevelWrapper._pendingElement = ReactElement.cloneAndReplaceProps(wrapElement, ReactElement.cloneAndReplaceProps(element, props));\n\n    enqueueUpdate(topLevelWrapper);\n  },\n\n  enqueueElementInternal: function (internalInstance, newElement) {\n    internalInstance._pendingElement = newElement;\n    enqueueUpdate(internalInstance);\n  }\n\n};\n\nmodule.exports = ReactUpdateQueue;\n};"],
"names":["shadow$provide","global","require","module","exports","getInternalInstanceReadyForUpdate","publicInstance","callerName","internalInstance","ReactInstanceMap","get","warning","constructor","displayName","ReactCurrentOwner","current","ReactElement","ReactUpdates","assign","invariant","ReactUpdateQueue","isMounted","owner","_warnedAboutRefsInRender","getName","_renderedComponent","enqueueCallback","callback","undefined","_pendingCallbacks","push","enqueueUpdate","enqueueCallbackInternal","enqueueForceUpdate","_pendingForceUpdate","enqueueReplaceState","completeState","_pendingStateQueue","_pendingReplaceState","enqueueSetState","partialState","enqueueSetProps","partialProps","enqueueSetPropsInternal","topLevelWrapper","_topLevelWrapper","wrapElement","_pendingElement","_currentElement","element","props","cloneAndReplaceProps","enqueueReplaceProps","enqueueReplacePropsInternal","enqueueElementInternal","newElement"]
}
