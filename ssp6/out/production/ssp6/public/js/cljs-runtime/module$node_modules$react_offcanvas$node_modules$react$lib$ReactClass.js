shadow$provide.module$node_modules$react_offcanvas$node_modules$react$lib$ReactClass=function(global,require,module,exports){function warnSetProps(){warnedSetProps||(warnedSetProps=!0,warning(!1,"setProps(...) and replaceProps(...) are deprecated. Instead, call render again at the top level."))}function validateTypeDef(Constructor,typeDef,location){for(var propName in typeDef)typeDef.hasOwnProperty(propName)&&warning("function"===typeof typeDef[propName],"%s: %s type `%s` is invalid; it must be a function, usually from React.PropTypes.",
Constructor.displayName||"ReactClass",ReactPropTypeLocationNames[location],propName)}function mixSpecIntoComponent(Constructor,spec){if(spec){"function"===typeof spec?invariant(!1,"ReactClass: You're attempting to use a component class as a mixin. Instead, just use a regular object."):void 0;ReactElement.isValidElement(spec)?invariant(!1,"ReactClass: You're attempting to use a component as a mixin. Instead, just use a regular object."):void 0;var proto=Constructor.prototype;spec.hasOwnProperty(MIXINS_KEY)&&
RESERVED_SPEC_KEYS.mixins(Constructor,spec.mixins);for(var name in spec)if(spec.hasOwnProperty(name)&&name!==MIXINS_KEY){var property=spec[name],proto$jscomp$0=proto,name$jscomp$0=name,specPolicy=ReactClassInterface.hasOwnProperty(name$jscomp$0)?ReactClassInterface[name$jscomp$0]:null;ReactClassMixin.hasOwnProperty(name$jscomp$0)&&(specPolicy!==SpecPolicy.OVERRIDE_BASE?invariant(!1,"ReactClassInterface: You are attempting to override `%s` from your class specification. Ensure that your method names do not overlap with React methods.",
name$jscomp$0):void 0);proto$jscomp$0.hasOwnProperty(name$jscomp$0)&&(specPolicy!==SpecPolicy.DEFINE_MANY&&specPolicy!==SpecPolicy.DEFINE_MANY_MERGED?invariant(!1,"ReactClassInterface: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.",name$jscomp$0):void 0);if(RESERVED_SPEC_KEYS.hasOwnProperty(name))RESERVED_SPEC_KEYS[name](Constructor,property);else proto$jscomp$0=ReactClassInterface.hasOwnProperty(name),name$jscomp$0=proto.hasOwnProperty(name),
"function"!==typeof property||proto$jscomp$0||name$jscomp$0||!1===spec.autobind?name$jscomp$0?(name$jscomp$0=ReactClassInterface[name],!proto$jscomp$0||name$jscomp$0!==SpecPolicy.DEFINE_MANY_MERGED&&name$jscomp$0!==SpecPolicy.DEFINE_MANY?invariant(!1,"ReactClass: Unexpected spec policy %s for key %s when mixing in component specs.",name$jscomp$0,name):void 0,name$jscomp$0===SpecPolicy.DEFINE_MANY_MERGED?proto[name]=createMergedResultFunction(proto[name],property):name$jscomp$0===SpecPolicy.DEFINE_MANY&&
(proto[name]=createChainedFunction(proto[name],property))):(proto[name]=property,"function"===typeof property&&spec.displayName&&(proto[name].displayName=spec.displayName+"_"+name)):(proto.__reactAutoBindMap||(proto.__reactAutoBindMap={}),proto.__reactAutoBindMap[name]=property,proto[name]=property)}}}function mergeIntoWithNoDuplicateKeys(one,two){one&&two&&"object"===typeof one&&"object"===typeof two?void 0:invariant(!1,"mergeIntoWithNoDuplicateKeys(): Cannot merge non-objects.");for(var key in two)two.hasOwnProperty(key)&&
(void 0!==one[key]?invariant(!1,"mergeIntoWithNoDuplicateKeys(): Tried to merge two objects with the same key: `%s`. This conflict may be due to a mixin; in particular, this may be caused by two getInitialState() or getDefaultProps() methods returning objects with clashing keys.",key):void 0,one[key]=two[key]);return one}function createMergedResultFunction(one,two){return function(){var a=one.apply(this,arguments),b=two.apply(this,arguments);if(null==a)return b;if(null==b)return a;var c={};mergeIntoWithNoDuplicateKeys(c,
a);mergeIntoWithNoDuplicateKeys(c,b);return c}}function createChainedFunction(one,two){return function(){one.apply(this,arguments);two.apply(this,arguments)}}function bindAutoBindMethod(component,method){var boundMethod=method.bind(component);boundMethod.__reactBoundContext=component;boundMethod.__reactBoundMethod=method;boundMethod.__reactBoundArguments=null;var componentName=component.constructor.displayName,_bind=boundMethod.bind;boundMethod.bind=function(newThis){for(var _len=arguments.length,
args=Array(1<_len?_len-1:0),_key=1;_key<_len;_key++)args[_key-1]=arguments[_key];if(newThis!==component&&null!==newThis)warning(!1,"bind(): React component methods may only be bound to the component instance. See %s",componentName);else if(!args.length)return warning(!1,"bind(): You are binding a component method to the component. React does this for you automatically in a high-performance way, so you can safely remove this call. See %s",componentName),boundMethod;_len=_bind.apply(boundMethod,arguments);
_len.__reactBoundContext=component;_len.__reactBoundMethod=method;_len.__reactBoundArguments=args;return _len};return boundMethod}global=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactComponent");var ReactElement=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactElement"),ReactPropTypeLocations=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactPropTypeLocations"),ReactPropTypeLocationNames=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactPropTypeLocationNames"),
ReactNoopUpdateQueue=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactNoopUpdateQueue"),assign=require("module$node_modules$react_offcanvas$node_modules$react$lib$Object_assign"),emptyObject=require("module$node_modules$fbjs$lib$emptyObject"),invariant=require("module$node_modules$fbjs$lib$invariant");exports=require("module$node_modules$fbjs$lib$keyMirror");var keyOf=require("module$node_modules$fbjs$lib$keyOf"),warning=require("module$node_modules$fbjs$lib$warning"),MIXINS_KEY=
keyOf({mixins:null}),SpecPolicy=exports({DEFINE_ONCE:null,DEFINE_MANY:null,OVERRIDE_BASE:null,DEFINE_MANY_MERGED:null}),injectedMixins=[],warnedSetProps=!1,ReactClassInterface={mixins:SpecPolicy.DEFINE_MANY,statics:SpecPolicy.DEFINE_MANY,propTypes:SpecPolicy.DEFINE_MANY,contextTypes:SpecPolicy.DEFINE_MANY,childContextTypes:SpecPolicy.DEFINE_MANY,getDefaultProps:SpecPolicy.DEFINE_MANY_MERGED,getInitialState:SpecPolicy.DEFINE_MANY_MERGED,getChildContext:SpecPolicy.DEFINE_MANY_MERGED,render:SpecPolicy.DEFINE_ONCE,
componentWillMount:SpecPolicy.DEFINE_MANY,componentDidMount:SpecPolicy.DEFINE_MANY,componentWillReceiveProps:SpecPolicy.DEFINE_MANY,shouldComponentUpdate:SpecPolicy.DEFINE_ONCE,componentWillUpdate:SpecPolicy.DEFINE_MANY,componentDidUpdate:SpecPolicy.DEFINE_MANY,componentWillUnmount:SpecPolicy.DEFINE_MANY,updateComponent:SpecPolicy.OVERRIDE_BASE},RESERVED_SPEC_KEYS={displayName:function(Constructor,displayName){Constructor.displayName=displayName},mixins:function(Constructor,mixins){if(mixins)for(var i=
0;i<mixins.length;i++)mixSpecIntoComponent(Constructor,mixins[i])},childContextTypes:function(Constructor,childContextTypes){validateTypeDef(Constructor,childContextTypes,ReactPropTypeLocations.childContext);Constructor.childContextTypes=assign({},Constructor.childContextTypes,childContextTypes)},contextTypes:function(Constructor,contextTypes){validateTypeDef(Constructor,contextTypes,ReactPropTypeLocations.context);Constructor.contextTypes=assign({},Constructor.contextTypes,contextTypes)},getDefaultProps:function(Constructor,
getDefaultProps){Constructor.getDefaultProps=Constructor.getDefaultProps?createMergedResultFunction(Constructor.getDefaultProps,getDefaultProps):getDefaultProps},propTypes:function(Constructor,propTypes){validateTypeDef(Constructor,propTypes,ReactPropTypeLocations.prop);Constructor.propTypes=assign({},Constructor.propTypes,propTypes)},statics:function(Constructor,statics){if(statics)for(var name in statics){var property=statics[name];statics.hasOwnProperty(name)&&(name in RESERVED_SPEC_KEYS?invariant(!1,
'ReactClass: You are attempting to define a reserved property, `%s`, that shouldn\'t be on the "statics" key. Define it as an instance property instead; it will still be accessible on the constructor.',name):void 0,name in Constructor?invariant(!1,"ReactClass: You are attempting to define `%s` on your component more than once. This conflict may be due to a mixin.",name):void 0,Constructor[name]=property)}},autobind:function(){}},ReactClassMixin={replaceState:function(newState,callback){this.updater.enqueueReplaceState(this,
newState);callback&&this.updater.enqueueCallback(this,callback)},isMounted:function(){return this.updater.isMounted(this)},setProps:function(partialProps,callback){warnSetProps();this.updater.enqueueSetProps(this,partialProps);callback&&this.updater.enqueueCallback(this,callback)},replaceProps:function(newProps,callback){warnSetProps();this.updater.enqueueReplaceProps(this,newProps);callback&&this.updater.enqueueCallback(this,callback)}},ReactClassComponent=function(){};assign(ReactClassComponent.prototype,
global.prototype,ReactClassMixin);module.exports={createClass:function(spec){var Constructor=function(props,context,updater){warning(this instanceof Constructor,"Something is calling a React component directly. Use a factory or JSX instead. See: https://fb.me/react-legacyfactory");if(this.__reactAutoBindMap)for(var autoBindKey in this.__reactAutoBindMap)this.__reactAutoBindMap.hasOwnProperty(autoBindKey)&&(this[autoBindKey]=bindAutoBindMethod(this,this.__reactAutoBindMap[autoBindKey]));this.props=
props;this.context=context;this.refs=emptyObject;this.updater=updater||ReactNoopUpdateQueue;this.state=null;props=this.getInitialState?this.getInitialState():null;"undefined"===typeof props&&this.getInitialState._isMockFunction&&(props=null);"object"!==typeof props||Array.isArray(props)?invariant(!1,"%s.getInitialState(): must return an object or null",Constructor.displayName||"ReactCompositeComponent"):void 0;this.state=props};Constructor.prototype=new ReactClassComponent;Constructor.prototype.constructor=
Constructor;injectedMixins.forEach(mixSpecIntoComponent.bind(null,Constructor));mixSpecIntoComponent(Constructor,spec);Constructor.getDefaultProps&&(Constructor.defaultProps=Constructor.getDefaultProps());Constructor.getDefaultProps&&(Constructor.getDefaultProps.isReactClassApproved={});Constructor.prototype.getInitialState&&(Constructor.prototype.getInitialState.isReactClassApproved={});Constructor.prototype.render?void 0:invariant(!1,"createClass(...): Class specification must implement a `render` method.");
warning(!Constructor.prototype.componentShouldUpdate,"%s has a method called componentShouldUpdate(). Did you mean shouldComponentUpdate()? The name is phrased as a question because the function is expected to return a value.",spec.displayName||"A component");warning(!Constructor.prototype.componentWillRecieveProps,"%s has a method called componentWillRecieveProps(). Did you mean componentWillReceiveProps()?",spec.displayName||"A component");for(var methodName in ReactClassInterface)Constructor.prototype[methodName]||
(Constructor.prototype[methodName]=null);return Constructor},injection:{injectMixin:function(mixin){injectedMixins.push(mixin)}}}}
//# sourceMappingURL=module$node_modules$react_offcanvas$node_modules$react$lib$ReactClass.js.map
