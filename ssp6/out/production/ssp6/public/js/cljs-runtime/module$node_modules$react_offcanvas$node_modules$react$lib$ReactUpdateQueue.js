shadow$provide.module$node_modules$react_offcanvas$node_modules$react$lib$ReactUpdateQueue=function(global,require,module,exports){function getInternalInstanceReadyForUpdate(publicInstance,callerName){var internalInstance=ReactInstanceMap.get(publicInstance);if(!internalInstance)return warning(!callerName,"%s(...): Can only update a mounted or mounting component. This usually means you called %s() on an unmounted component. This is a no-op. Please check the code for the %s component.",callerName,
callerName,publicInstance.constructor.displayName),null;warning(null==ReactCurrentOwner.current,"%s(...): Cannot update during an existing state transition (such as within `render`). Render methods should be a pure function of props and state.",callerName);return internalInstance}var ReactCurrentOwner=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactCurrentOwner"),ReactElement=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactElement"),ReactInstanceMap=
require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactInstanceMap"),ReactUpdates=require("module$node_modules$react_offcanvas$node_modules$react$lib$ReactUpdates"),assign=require("module$node_modules$react_offcanvas$node_modules$react$lib$Object_assign"),invariant=require("module$node_modules$fbjs$lib$invariant"),warning=require("module$node_modules$fbjs$lib$warning"),ReactUpdateQueue={isMounted:function(publicInstance){var owner=ReactCurrentOwner.current;null!==owner&&(warning(owner._warnedAboutRefsInRender,
"%s is accessing isMounted inside its render() function. render() should be a pure function of props and state. It should never access something that requires stale data from the previous render, such as refs. Move this logic to componentDidMount and componentDidUpdate instead.",owner.getName()||"A component"),owner._warnedAboutRefsInRender=!0);return(publicInstance=ReactInstanceMap.get(publicInstance))?!!publicInstance._renderedComponent:!1},enqueueCallback:function(publicInstance,callback){"function"!==
typeof callback?invariant(!1,"enqueueCallback(...): You called `setProps`, `replaceProps`, `setState`, `replaceState`, or `forceUpdate` with a callback that isn't callable."):void 0;publicInstance=getInternalInstanceReadyForUpdate(publicInstance);if(!publicInstance)return null;publicInstance._pendingCallbacks?publicInstance._pendingCallbacks.push(callback):publicInstance._pendingCallbacks=[callback];ReactUpdates.enqueueUpdate(publicInstance)},enqueueCallbackInternal:function(internalInstance,callback){"function"!==
typeof callback?invariant(!1,"enqueueCallback(...): You called `setProps`, `replaceProps`, `setState`, `replaceState`, or `forceUpdate` with a callback that isn't callable."):void 0;internalInstance._pendingCallbacks?internalInstance._pendingCallbacks.push(callback):internalInstance._pendingCallbacks=[callback];ReactUpdates.enqueueUpdate(internalInstance)},enqueueForceUpdate:function(publicInstance){if(publicInstance=getInternalInstanceReadyForUpdate(publicInstance,"forceUpdate"))publicInstance._pendingForceUpdate=
!0,ReactUpdates.enqueueUpdate(publicInstance)},enqueueReplaceState:function(publicInstance,completeState){if(publicInstance=getInternalInstanceReadyForUpdate(publicInstance,"replaceState"))publicInstance._pendingStateQueue=[completeState],publicInstance._pendingReplaceState=!0,ReactUpdates.enqueueUpdate(publicInstance)},enqueueSetState:function(publicInstance,partialState){if(publicInstance=getInternalInstanceReadyForUpdate(publicInstance,"setState"))(publicInstance._pendingStateQueue||(publicInstance._pendingStateQueue=
[])).push(partialState),ReactUpdates.enqueueUpdate(publicInstance)},enqueueSetProps:function(publicInstance,partialProps){(publicInstance=getInternalInstanceReadyForUpdate(publicInstance,"setProps"))&&ReactUpdateQueue.enqueueSetPropsInternal(publicInstance,partialProps)},enqueueSetPropsInternal:function(internalInstance,partialProps){(internalInstance=internalInstance._topLevelWrapper)?void 0:invariant(!1,"setProps(...): You called `setProps` on a component with a parent. This is an anti-pattern since props will get reactively updated when rendered. Instead, change the owner's `render` method to pass the correct value as props to the component where it is created.");
var wrapElement=internalInstance._pendingElement||internalInstance._currentElement,element=wrapElement.props;partialProps=assign({},element.props,partialProps);internalInstance._pendingElement=ReactElement.cloneAndReplaceProps(wrapElement,ReactElement.cloneAndReplaceProps(element,partialProps));ReactUpdates.enqueueUpdate(internalInstance)},enqueueReplaceProps:function(publicInstance,props){(publicInstance=getInternalInstanceReadyForUpdate(publicInstance,"replaceProps"))&&ReactUpdateQueue.enqueueReplacePropsInternal(publicInstance,
props)},enqueueReplacePropsInternal:function(internalInstance,props){(internalInstance=internalInstance._topLevelWrapper)?void 0:invariant(!1,"replaceProps(...): You called `replaceProps` on a component with a parent. This is an anti-pattern since props will get reactively updated when rendered. Instead, change the owner's `render` method to pass the correct value as props to the component where it is created.");var wrapElement=internalInstance._pendingElement||internalInstance._currentElement;internalInstance._pendingElement=
ReactElement.cloneAndReplaceProps(wrapElement,ReactElement.cloneAndReplaceProps(wrapElement.props,props));ReactUpdates.enqueueUpdate(internalInstance)},enqueueElementInternal:function(internalInstance,newElement){internalInstance._pendingElement=newElement;ReactUpdates.enqueueUpdate(internalInstance)}};module.exports=ReactUpdateQueue}
//# sourceMappingURL=module$node_modules$react_offcanvas$node_modules$react$lib$ReactUpdateQueue.js.map
