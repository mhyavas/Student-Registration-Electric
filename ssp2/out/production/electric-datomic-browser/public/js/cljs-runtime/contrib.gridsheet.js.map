{"version":3,"sources":["contrib/gridsheet.cljc"],"mappings":";;;;AAYA,AAwEA","names":[],"sourcesContent":["(ns contrib.gridsheet\n  \"todo deprecate, use HFQL grid. Used by datomic-browser and folder-explorer\"\n  #?(:cljs (:require-macros contrib.gridsheet))\n  (:require clojure.math\n            [contrib.assert :refer [check]]\n            [contrib.data :refer [auto-props round-floor]]\n            [hyperfiddle.electric :as e]\n            [hyperfiddle.electric-dom2 :as dom]\n            [hyperfiddle.electric-ui4 :as ui]\n            [hyperfiddle.history :as router] ; todo remove\n            #?(:cljs goog.object)))\n\n(e/defn GridSheet [xs props]\n  (let [props (auto-props props\n                {::row-height 24\n                 ::page-size 20})\n        {:keys [::Format\n                ::columns\n                ::grid-template-columns\n                ::row-height ; px, same unit as scrollTop\n                ::page-size #_ \"tight\"]} props\n        Format (or Format (e/fn [m a] (e/client (dom/text (pr-str (a m))))))\n        client-height (* (inc (check number? page-size)) (check number? row-height))\n        rows (seq xs)\n        row-count (count rows)]\n    (assert columns \"gridsheet: ::columns prop is required\")\n    (e/client\n      (dom/div (dom/props {:role \"grid\"\n                           :class (e/server (::dom/class props))\n                           :style (merge (e/server (::dom/style props))\n                                    {:height (str client-height \"px\")\n                                     :display \"grid\" :overflowY \"auto\"\n                                     :grid-template-columns (or (e/server (::grid-template-columns props))\n                                                              (->> (repeat (e/server (count columns)) \"1fr\")\n                                                                (interpose \" \") (apply str)))})})\n        (let [[scroll-top scroll-height client-height'] (new (ui/scroll-state< dom/node))\n              max-height (* row-count row-height)\n              padding-bottom (js/Math.max (- max-height client-height) 0)\n\n              ; don't scroll past the end\n              clamped-scroll-top (js/Math.min scroll-top padding-bottom)\n\n              start-row (clojure.math/ceil (/ clamped-scroll-top row-height))\n\n              ; batch pagination to improve latency\n              ; (does reducing network even help or just making loads happen offscreen?)\n              ; clamp start to the nearest page\n              start-row-page-aligned (round-floor start-row page-size)]\n          #_(println [:scrollTop scroll-top :scrollHeight scroll-height :clientHeight client-height\n                    :padding-bottom padding-bottom\n                    :start-row start-row :start-row-page-aligned start-row-page-aligned\n                    :take page-size :max-height max-height])\n\n          (e/for [k columns]\n            (dom/div (dom/props {:role \"columnheader\"\n                                 :style {:position \"sticky\" #_\"fixed\" :top (str 0 \"px\")\n                                         :background-color \"rgb(248 250 252)\" :box-shadow \"0 1px gray\"}})\n              (dom/text (name k))))\n\n          ; userland could format the row, no need\n          ; for grid to be aware of columns, it's just vertical scroll.\n          ; horizontal scroll changes things.\n          ; except for the tricky styles ...\n          (e/server\n            (when (seq rows) (check vector? (first rows)))\n            (let [xs (vec (->> rows (drop start-row) (take page-size)))]\n              (e/for [i (range page-size)]\n                (let [[depth m] (get xs i [0 ::empty])]\n                  (e/client\n                    (dom/div (dom/props {:role \"group\" :style {:display \"contents\"\n                                                               :grid-row (inc i)}})\n                      (dom/div (dom/props {:role \"gridcell\"\n                                           :style {:padding-left (-> depth (* 15) (str \"px\"))\n                                                   :position \"sticky\" :top (str (* row-height (inc i)) \"px\")\n                                                   :height (str row-height \"px\")}})\n                        (e/server (case m ::empty nil (Format. m (first columns))))) ; for effect\n                      (e/for [a (rest columns)]\n                        (dom/div (dom/props {:role \"gridcell\"\n                                             :style {:position \"sticky\" :top (str (* row-height (inc i)) \"px\")\n                                                     :height (str row-height \"px\")}})\n                          (e/server (case m ::empty nil (Format. m a))))))))))) ; for effect\n          (dom/div (dom/props {:style {:padding-bottom (str padding-bottom \"px\")}})))) ; scrollbar\n      (dom/div (dom/text (pr-str {:count row-count}))))))\n\n(e/defn Explorer [query-fn props]\n  (e/client\n    (let [{:keys [::search] :as s} router/route]\n      (ui/input search (e/fn V! [v] (router/swap-route! assoc ::search v)) ; todo (swap! router/!route assoc ::search v)\n        (dom/props {:placeholder \"Search\" :type \"search\"}))\n      (dom/hr)\n      (e/server\n        (GridSheet. (query-fn search) props)))))"],"x_google_ignoreList":[0]}