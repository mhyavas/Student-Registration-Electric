{"version":3,"sources":["contrib/str.cljc"],"mappings":";AAOA,yBAAA,zBAAMA,0DAAYC;AAAlB,AACE,IAAAC,mBAAA,KAAAC;AAAA,AAAA,IAAAC,oDAAAC;IAAAC,+CAAAC;IAAAC,oDAAA;IAAAC,+CAAA,WAAAC;AAAA,AAAA,OAAAR,wBAAAQ;;AAAA,AAAA,CAAAL,sCAAAG;;AAAA,CAAAD,iCAAAE;;AAAA,IAAA,AACE,IAAAE,yDAAUE;IAAVD,yDAAA;AAAA,AAAA,8CAAAA,7CAAUC;;AAAV,IAAA,AAGE,IAAAC,4DAAAC;IAAAC,4DACEC;AADF,AAAA,CAAAF,gDAAAC;;AAAA,IAAA,AAEE,AAACE,iDAAsBjB;UAFzB,AAAA,CAAAc,gDAAAD;WAHF,AAAA,8CAAAH,7CAAUE;WADZ,AAAA,CAAAN,iCAAAD;;AAAA,CAAAD,sCAAAD;;AAAA,mDAAAF;;AAQF,AAYA,kCAAA,lCAAmBiB,4EAAeC,EAAEC;AAApC,AASE,OAACC,+BAAyB,AAACC,0BAA0B,4CAAKH,IAChC,AAACG,0BAA0B,4CAAKF;;AAE5D,AASA,iCAAA,jCAAMG,0EAAcC,KAAKJ;AAAzB,AACE,IAAMK,SAAO,AAACH,0BAA0B,4CAAKF;AAA7C,AACE,sBAAA,WAAAM,1BAACC;AAAD,AAAO,oBAAAD;AAAA,AAAQ,OAACL,+BAAyB,AAACC,0BAA0B,4CAAAI,oBAASD;;AAAtE;;GAA+ED;;AAE1F,AAOA,2BAAA,3BAAMI,8DAAQC;AAAd,AAAiB,SAAI,EAAK,OAASA,oBAAG,wBAAA,vBAAO,AAACC,gBAAMD,mBAC/B,MAAA,LAAMA;;AAE3B,AAKA,4BAAA,5BAAME,gEAAYF;AAAlB,AAAqB,GAAI,AAACD,yBAAOC;AAAZ;;AAAmBA;;;AAExC,AAMA;;;4BAAA,5BAAMG,gEAAmEH;AAAzE,AACE,GAAA,GAAQ,OAASA;AACfA;;AACA,GAAA,GAAQ,AAACI,4BAAsBJ;AAAGA;;AAAlC;;;;AAEJ,AAWA,AAAA,qBAAA,6BAAAK,lDAAME;AAAN,AAAA,IAAAD,YAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,iDAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;KAAA;AAAA,OAAAA,iDAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAA,CAAA,UAAA;;;;AAAA,MAAA,KAAAC,MAAA,CAAA,8DAAA,AAAA;;;;;AAAA,CAAA,mDAAA,nDAAMD,8DAEFE,EAAEC;AAFN,AAES,IAAAC,oBAASF;AAAT,AAAA,GAAA,cAAAE,dAAKE;AAALF;;AAAA,IAAAC,oBAAWF;AAAX,AAAA,GAAA,cAAAE,dAAKC;AAAL,AAAAD;;AAAA;;;;;AAFT,CAAA,mDAAA,nDAAML,8DAGFE,EAAEC,EAAEI;AAHR,AAGW,IAAAH,oBAASF;AAAT,AAAA,GAAA,cAAAE,dAAKE;AAALF;;AAAA,IAAAA,wBAAWD;AAAX,AAAA,GAAA,cAAAC,dAAKE;AAALF;;AAAA,IAAAC,oBAAaE;AAAb,AAAA,GAAA,cAAAF,dAAKC;AAAL,AAAAD;;AAAA;;;;;;AAHX,CAAA,6CAAA,7CAAML;;AAAN,AAKA","names":["contrib.str/pprint-str","x","sb__5690__auto__","goog.string/StringBuffer","*print-newline*-orig-val__102093","cljs.core/*print-newline*","*print-fn*-orig-val__102094","cljs.core/*print-fn*","*print-newline*-temp-val__102095","*print-fn*-temp-val__102096","x__5691__auto__","*print-right-margin*-orig-val__102097","*print-right-margin*-temp-val__102098","cljs.pprint/*print-right-margin*","*print-pprint-dispatch*-orig-val__102099","cljs.pprint/*print-pprint-dispatch*","*print-pprint-dispatch*-temp-val__102100","cljs.pprint/code-dispatch","cljs.pprint.pprint","contrib.str/includes-str?","v","needle","clojure.string/includes?","clojure.string/lower-case","contrib.str/any-matches?","coll","substr","p1__102101#","cljs.core/some","contrib.str/empty?","s","cljs.core/count","contrib.str/empty->nil","contrib.str/blank->nil","clojure.string/blank?","var_args","G__102103","contrib.str/or-str","js/Error","a","b","or__28135__auto__","or__28134__auto__","cljs.core/seq","c"],"sourcesContent":["(ns contrib.str\r\n  (:refer-clojure :exclude [empty?])\r\n  (:require clojure.pprint\r\n            clojure.string\r\n            [contrib.data :refer [orp]]\r\n            [hyperfiddle.rcf :refer [tests]]))\r\n\r\n(defn pprint-str [x]\r\n  (with-out-str\r\n    (binding [clojure.pprint/*print-right-margin* 100\r\n              #_#_clojure.pprint/*print-miser-width* 1\r\n              #_#_clojure.pprint/*print-pprint-dispatch* hyperfiddle.pprint/simple-dispatch]\r\n      (clojure.pprint/with-pprint-dispatch\r\n        clojure.pprint/code-dispatch\r\n        (clojure.pprint/pprint x)))))\r\n\r\n(comment\r\n  (pprint-str (range 50))\r\n  (pprint-str '{(user.gender-shirt-size/submissions \"\" .)\r\n                [{:db/id 9}\r\n                 {:db/id 10}\r\n                 {:db/id 11}]})\r\n  (pprint-str '{(user.gender-shirt-size/submissions \"bob\" .)\r\n                [{:dustingetz/gender {:db/ident :dustingetz/male},\r\n                  :dustingetz/email \"bob@example.com\",\r\n                  :dustingetz/shirt-size {:db/ident :dustingetz/mens-large},\r\n                  :db/id 10}]}))\r\n\r\n(defn ^:deprecated includes-str? [v needle]\r\n  ; perf - https://clojurians.slack.com/archives/C03RZMDSH/p1666290300539289\r\n  ; want to reduce memory pressure moreso than optimzie the speed\r\n  ; if you want a case-insensitive match I recommend using something which doesn\u2019t force new string\r\n  ; allocations; use org.apache.commons.lang3.StringUtils.containsIgnoreCase() which uses\r\n  ; String.regionMatches under the hood. Or better yet use d/filter on d/datoms (can we pass that\r\n  ; as an input to another query?)\r\n\r\n  ; Is this deprecated because of performances?\r\n  (clojure.string/includes? (clojure.string/lower-case (str v))\r\n                            (clojure.string/lower-case (str needle))))\r\n\r\n(tests\r\n  (includes-str? \"alice\" \"e\") := true\r\n  (includes-str? \"alice\" \"f\") := false\r\n  (includes-str? \"alice\" \"\") := true\r\n  (includes-str? \"alice\" nil) := true\r\n  (includes-str? nil nil) := true\r\n  (includes-str? nil \"\") := true\r\n  (includes-str? \"\" nil) := true)\r\n\r\n(defn any-matches? [coll needle]\r\n  (let [substr (clojure.string/lower-case (str needle))]\r\n    (some #(when % (clojure.string/includes? (clojure.string/lower-case (str %)) substr)) coll)))\r\n\r\n(tests\r\n  (any-matches? [1 2 nil 3] \"3\") := true\r\n  (any-matches? [\"xyz\"] \"Y\") := true\r\n  (any-matches? [\"ABC\"] \"abc\") := true\r\n  (any-matches? [\"abc\"] \"d\") := nil)\r\n\r\n\r\n(defn empty? [s] (or (and (string? s) (zero? (count s)))\r\n                     (nil? s)))\r\n\r\n(tests\r\n  (empty? \"\") := true\r\n  (empty? nil) := true\r\n  (empty? \" \") := false)\r\n\r\n(defn empty->nil [s] (if (empty? s) nil s))\r\n\r\n(tests\r\n  (empty->nil nil) := nil\r\n  (empty->nil \"\") := nil\r\n  (empty->nil \" \") := \" \"\r\n  (empty->nil \"a\") := \"a\")\r\n\r\n(defn blank->nil \"Nullify empty strings, identity on all other values.\" [s]\r\n  (if-not (string? s)\r\n    s ; don't fail\r\n    (if-not (clojure.string/blank? s) s nil)))\r\n\r\n(tests\r\n  (blank->nil nil) := nil\r\n  (blank->nil \"\") := nil\r\n  (blank->nil \" \") := nil\r\n  (blank->nil \"      \") := nil\r\n  (blank->nil \"a\") := \"a\"\r\n  (not= (blank->nil \"   a\") nil) := true\r\n  (not= (blank->nil \"   a   \") nil) := true\r\n  (blank->nil 1) := 1\r\n  (blank->nil nil) := nil)\r\n\r\n(defn or-str\r\n  #_([& args] (apply orp seq args))                         ; can't apply macro todo\r\n  ([a b] (orp seq a b))\r\n  ([a b c] (orp seq a b c)))\r\n\r\n(tests\r\n  (or-str nil \"b\") := \"b\"\r\n  (or-str \"\" \"b\") := \"b\"\r\n  (or-str \"a\" \"b\") := \"a\"\r\n  (or-str \" \" \"b\") := \" \")"]}