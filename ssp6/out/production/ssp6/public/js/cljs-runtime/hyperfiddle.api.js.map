{"version":3,"sources":["hyperfiddle/api.cljc"],"mappings":";;;;AAUA,AACA,AACA,AAAAA,yBAAA,AAAA,kFAAA,AAAA,2EAAcC;AACd,AACA,AACA,AACA,AAAKC,wCAAsB,wEAAA,2CAAA,4DAAA,2CAAA,AAAA,1NAACC,gDAAQC,mPACoCC;AAExE,AACA,AAIA,AACA,AAEA,AACA,AACA,AAOA,yBAAA,zBAAMC,0DAAQC;AAAd,AAAmB,IAAAC,mBAAI,AAAA,oHAAUD;AAAd,AAAA,oBAAAC;AAAAA;;AAAmB,OAAA,oHAAU,AAAA,oHAAUD;;;AAC1D,4BAAA,5BAAME,gEAAWF;AAAjB,AAAsB,IAAAC,mBAAI,AAAA,yHAAaD;AAAjB,AAAA,oBAAAC;AAAAA;;AAAsB,OAAA,yHAAa,AAAA,oHAAUD;;;AAEnE,AAEA,AASA,GAAA,QAAAG,wCAAAC,4CAAAC;AAAA;AAAA,AAAA,0BAAA,iBAAAC,6BAAA,AAAAC,6CAAA,rHAAUS;IAAVR,6BAAA,AAAAD,6CAAA;IAAAE,6BAAA,AAAAF,6CAAA;IAAAG,iCAAA,AAAAH,6CAAA;IAAAI,0BAAA,AAAAC,4CAAA,mCAAA,gEAAA,iBAAAC,eAAA;AAAA,AAAA,QAAAA,6CAAAA,+CAAAA;;AAAA,AAAA,YAAAC,kBAAA,AAAAC,+CAAA,kBAAA,WAAkB,WAAKE,OAAOC;AAAZ,AAAgB,GAAI,AAACC,qBAAKD;AAAV;;AAAoB,OAACE,gBAAMF;;GAA7D,4DAAAP,wBAAAL,2BAAAE,2BAAAC,2BAAAC;;;AAEA,AAAAjB,yBAAA,AAAA,sGAAA,AAAA,yMAAwB,AAAA4B,6BAAA,mFAAA,0DAAA,AAAA,gJAAA,mFAAA,6DAAA;AACxB,AAAA5B,yBAAA,AAAA,mGAAA,AAAA,2EAAuB0B;AACvB,AAAA1B,yBAAA,AAAA,6FAAA,AAAA,sEAAoB6B;AACpB,AAAA7B,yBAAA,AAAA,6FAAA,AAAA,sEAAoB6B;AACpB,AAAA7B,yBAAA,AAAA,yGAAA,AAAA,62BAA0B,AAAA8B,8BAAA,wCAAA,yDAAA,wDAAA,kDAAA,iEAAA,8DAAA,6DAAA,8DAAA,mDAAA,4DAAA,+DAAA,gEAAA,qDAAA,AAAA,KAAA,AAAA,KAAA,KAAA,mFAAA,WAAAC;AAAA,AAAA,OAAAL,qBAAAK;GAAA,WAAAA;AAAA,AAAA,OAAAC,0BAAAD,SAAA;WAAA,WAAAA;AAAA,AAAA,SAAA,AAAAL,qBAAAK,eAAA,AAAAC,0BAAAD,SAAA;GAAA,AAAA,meAAA,AAAA,8LAAA,AAAA,8LAAA,AAAA,8LAAA,AAAA,meAAA,AAAA,66BAAA,AAAA;AAG1B,AAAA/B,yBAAA,AAAA,6FAAA,AAAA,qQAAA,AAAAiC,2BAAA,KAAA,AAAA,KAAA,AAAAC,wDAAA,AAAA,yGAAA,yGAAA,KAAA,MAAA,AAAA,yGAAA,KAAA,AAAA,KAAA;AAcA,AAYA,AACA,AACA,AAEA,AASA,AA0BA,AACA,AAEA","names":["cljs.spec.alpha/def-impl","cljs.core/any?","hyperfiddle.api/-read-edn-str-default","cljs.core.partial","clojure.edn/read-string","hyperfiddle.api.goog$module$goog$math$Long.fromString","hyperfiddle.api/entity","ctx","or__5045__auto__","hyperfiddle.api/attribute","js/hyperfiddle","js/hyperfiddle.api","js/hyperfiddle.api.tx-meta","method-table__5642__auto__","cljs.core.atom","prefer-table__5643__auto__","method-cache__5644__auto__","cached-hierarchy__5645__auto__","hierarchy__5646__auto__","cljs.core.get","fexpr__34318","cljs.core/MultiFn","cljs.core.symbol","hyperfiddle.api/tx-meta","schema","tx","cljs.core/map?","cljs.core/first","cljs.spec.alpha/or-spec-impl","cljs.core/fn?","cljs.spec.alpha/map-spec-impl","G__34322","cljs.core/contains?","cljs.spec.alpha/fspec-impl","cljs.spec.alpha.spec_impl"],"sourcesContent":["(ns hyperfiddle.api\n  (:import [hyperfiddle.electric Pending]\n           #?(:cljs [goog.math Long]))\n  (:require clojure.edn\n            [contrib.dynamic :refer [call-sym]]\n            [clojure.spec.alpha :as s]\n            [hyperfiddle.electric :as e]\n            [missionary.core :as m]\n            hyperfiddle.electric-dom2))\n\n(def ^:dynamic *$*) ; dbval, for REPL usage. Available in cljs for HFQL datascript tests\n(e/def db \"inject database value for hyperfiddle stage and HFQL\")\n(s/def ::ref? any?)\n(e/def secure-db \"database value excluding stage, so that user can't tamper\")\n(e/def with \"inject datomic.api/with or equivalent, used by stage\")\n(e/def into-tx')\n(def -read-edn-str-default (partial clojure.edn/read-string\n                                    {:readers #?(:cljs {'goog.math/Long goog.math.Long/fromString} ; datomic cloud long ids\n                                                :clj {})}))\n(e/def read-edn-str \"inject app-specific edn extensions\" -read-edn-str-default) ; avoid Electric warning about goog.math.Long\n(e/def ^:dynamic *nav!*)\n\n;;; Database\n\n(def db-state #?(:clj (atom nil))) ; Server side only\n(e/def db-name \"$\")\n\n(e/def schema \"pre-fetched schema for explorer\")\n(e/def ^{:dynamic true, :doc \"To be bound to a function [db attribute] -> schema\"} *schema*)\n(e/def ^{:dynamic true, :doc \"To be bound to a function schema -> ::hf/one | ::hf/many\"} *cardinality*\n  (fn cardinality [schemaf db attr]\n    (let [card\n          ({:db.cardinality/one ::one\n            :db.cardinality/many ::many} (:db/cardinality (schemaf db attr)))]\n      card)))\n\n(defn entity [ctx] (or (::entity ctx) (::entity (::parent ctx))))\n(defn attribute [ctx] (or (::attribute ctx) (::attribute (::parent ctx))))\n\n(e/def validation-hints nil)\n\n(e/defn tx \"WIP, this default impl captures the essence\" [v' props] ; meant to be called by a renderer\n  ;; Does it return a tx or side-effect to the staging area?\n  (assert false \"TBD\")\n  #_(if-let [Txfn (::tx props)] ; provided by hfql (props ... {::hf/tx (p/fn [] ...)})\n      (Txfn. v')\n      (when v'\n        (let [[E a _] (first context)] ; context is a stack of [[E a] ...] in dynamic scope ; MISSING today\n          [[:db/add (E.) a v']]))))\n\n(defmulti tx-meta (fn [schema tx] (if (map? tx) ::map (first tx))))\n\n(s/def ::tx-cardinality (s/or :one :many))\n(s/def ::tx-identifier map?)\n(s/def ::tx-inverse fn?)\n(s/def ::tx-special fn?)\n(s/def ::transaction-meta (s/keys :req [::tx-identifier]\n                                  :opt [::tx-cardinality ::tx-inverse ::tx-special\n                                        ::tx-conflicting?]))\n(s/fdef tx-meta :ret ::transaction-meta)\n\n; resolve cycle - hyperfiddle.txn needs hf/tx-meta\n#?(:clj (require 'hyperfiddle.txn)) ; [rosie] before rcf turns on due to test/seattle undefined\n#?(:clj (defn expand-hf-tx [tx] (call-sym 'hyperfiddle.txn/expand-hf-tx tx)))\n;#?(:clj\n;   (defmacro into-tx\n;     ([tx tx'] `(call-sym ~'hyperfiddle.txn/into-tx ~hyperfiddle.api/schema ~tx ~tx')) ; Electric call can infer schema\n;     ([schema tx tx'] `(call-sym ~'hyperfiddle.txn/into-tx ~schema ~tx ~tx'))) ; clojure compatible call\n;   :cljs (def into-tx nil))\n#?(:clj (defn into-tx\n          ;([tx tx'] (into-tx schema tx tx')) -- needs Electric->Clojure binding conveyance\n          ([schema tx tx'] (call-sym 'hyperfiddle.txn/into-tx schema tx tx'))))\n\n(e/defn Transact!* [!t tx] ; colorless, !t on server\n  ; need the flattening be atomic?\n  #_(when-some [tx (seq (hyperfiddle.txn/minimal-tx hyperfiddle.api/db tx))]) ; stabilize first loop (optional)\n  (new (e/task->cp\n         ;; workaround: Datomic doesn't handle a thread interrupt correctly\n         (m/compel\n           (m/via m/blk\n             ;; return basis-t ?\n             (swap! !t (fn [[db tx0]]\n                         [(with db tx) ; injected datomic dep\n                          (into-tx' schema tx0 tx)]))))))) ; datascript is different\n\n(e/def Transact!) ; server\n(e/def stage) ; server\n(e/def loading) ; client\n\n(e/defn Load-timer []\n  (e/client\n    (let [[x] (e/with-cycle [[elapsed start :as s] [0 nil]]\n                (case hyperfiddle.api/loading\n                  true [(some->> start (- e/system-time-ms))\n                             (js/Date.now)]\n                  s))]\n      x)))\n\n(e/defn Branch [Body-server] ; todo colorless\n  (e/server\n    (let [!ret (atom nil)\n          !t (atom #_::unknown [db []])\n          [db stage] (e/watch !t)]\n      (binding [hyperfiddle.api/db db\n                hyperfiddle.api/stage stage\n                hyperfiddle.api/Transact! (e/fn [tx]\n                                            #_(println \"Transact! \" (hash !t) \"committing: \" tx)\n                                            (let [r (Transact!*. !t tx)]\n                                              #_(println \"Transact! \" (hash !t) \"commit result: \" r)))]\n        (e/client\n          (e/with-cycle [loading false]\n            (binding [hyperfiddle.api/loading loading]\n              #_(dom/div (name loading) \" \" (str (Load-timer.)) \"ms\")\n              (try\n                (e/server\n                  (let [x (Body-server.)] ; cycle x?\n                    #_(println 'Branch x)\n                    (reset! !ret x))) ; if the body returns something, return it. (Likely not used)\n                false (catch Pending e true))))\n          nil))\n      (e/watch !ret)))) ; do we need this? Popover using it currently\n\n(defmacro branch [& body] `(new Branch (e/fn [] ~@body)))\n\n(e/def page-drop -1)\n(e/def page-take -1)\n\n(e/defn Paginate [xs]\n  (if (coll? xs)\n    (cond->> xs\n      (pos-int? page-drop) (drop page-drop)\n      (pos-int? page-take) (take page-take))\n    xs))\n"],"x_google_ignoreList":[0]}