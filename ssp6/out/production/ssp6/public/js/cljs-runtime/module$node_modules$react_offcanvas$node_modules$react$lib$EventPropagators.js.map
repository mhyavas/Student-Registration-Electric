{
"version":3,
"file":"module$node_modules$react_offcanvas$node_modules$react$lib$EventPropagators.js",
"lineCount":5,
"mappings":"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",
"sources":["node_modules/react-offcanvas/node_modules/react/lib/EventPropagators.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$react_offcanvas$node_modules$react$lib$EventPropagators\"] = function(global,require,module,exports) {\n/**\n * Copyright 2013-2015, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule EventPropagators\n */\n\n'use strict';\n\nvar EventConstants = require('./EventConstants');\nvar EventPluginHub = require('./EventPluginHub');\n\nvar warning = require('fbjs/lib/warning');\n\nvar accumulateInto = require('./accumulateInto');\nvar forEachAccumulated = require('./forEachAccumulated');\n\nvar PropagationPhases = EventConstants.PropagationPhases;\nvar getListener = EventPluginHub.getListener;\n\n/**\n * Some event types have a notion of different registration names for different\n * \"phases\" of propagation. This finds listeners by a given phase.\n */\nfunction listenerAtPhase(id, event, propagationPhase) {\n  var registrationName = event.dispatchConfig.phasedRegistrationNames[propagationPhase];\n  return getListener(id, registrationName);\n}\n\n/**\n * Tags a `SyntheticEvent` with dispatched listeners. Creating this function\n * here, allows us to not have to bind or create functions for each event.\n * Mutating the event's members allows us to not have to create a wrapping\n * \"dispatch\" object that pairs the event with the listener.\n */\nfunction accumulateDirectionalDispatches(domID, upwards, event) {\n  if (process.env.NODE_ENV !== 'production') {\n    process.env.NODE_ENV !== 'production' ? warning(domID, 'Dispatching id must not be null') : undefined;\n  }\n  var phase = upwards ? PropagationPhases.bubbled : PropagationPhases.captured;\n  var listener = listenerAtPhase(domID, event, phase);\n  if (listener) {\n    event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n    event._dispatchIDs = accumulateInto(event._dispatchIDs, domID);\n  }\n}\n\n/**\n * Collect dispatches (must be entirely collected before dispatching - see unit\n * tests). Lazily allocate the array to conserve memory.  We must loop through\n * each event and perform the traversal for each one. We cannot perform a\n * single traversal for the entire collection of events because each event may\n * have a different target.\n */\nfunction accumulateTwoPhaseDispatchesSingle(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginHub.injection.getInstanceHandle().traverseTwoPhase(event.dispatchMarker, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Same as `accumulateTwoPhaseDispatchesSingle`, but skips over the targetID.\n */\nfunction accumulateTwoPhaseDispatchesSingleSkipTarget(event) {\n  if (event && event.dispatchConfig.phasedRegistrationNames) {\n    EventPluginHub.injection.getInstanceHandle().traverseTwoPhaseSkipTarget(event.dispatchMarker, accumulateDirectionalDispatches, event);\n  }\n}\n\n/**\n * Accumulates without regard to direction, does not look for phased\n * registration names. Same as `accumulateDirectDispatchesSingle` but without\n * requiring that the `dispatchMarker` be the same as the dispatched ID.\n */\nfunction accumulateDispatches(id, ignoredDirection, event) {\n  if (event && event.dispatchConfig.registrationName) {\n    var registrationName = event.dispatchConfig.registrationName;\n    var listener = getListener(id, registrationName);\n    if (listener) {\n      event._dispatchListeners = accumulateInto(event._dispatchListeners, listener);\n      event._dispatchIDs = accumulateInto(event._dispatchIDs, id);\n    }\n  }\n}\n\n/**\n * Accumulates dispatches on an `SyntheticEvent`, but only for the\n * `dispatchMarker`.\n * @param {SyntheticEvent} event\n */\nfunction accumulateDirectDispatchesSingle(event) {\n  if (event && event.dispatchConfig.registrationName) {\n    accumulateDispatches(event.dispatchMarker, null, event);\n  }\n}\n\nfunction accumulateTwoPhaseDispatches(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingle);\n}\n\nfunction accumulateTwoPhaseDispatchesSkipTarget(events) {\n  forEachAccumulated(events, accumulateTwoPhaseDispatchesSingleSkipTarget);\n}\n\nfunction accumulateEnterLeaveDispatches(leave, enter, fromID, toID) {\n  EventPluginHub.injection.getInstanceHandle().traverseEnterLeave(fromID, toID, accumulateDispatches, leave, enter);\n}\n\nfunction accumulateDirectDispatches(events) {\n  forEachAccumulated(events, accumulateDirectDispatchesSingle);\n}\n\n/**\n * A small set of propagation patterns, each of which will accept a small amount\n * of information, and generate a set of \"dispatch ready event objects\" - which\n * are sets of events that have already been annotated with a set of dispatched\n * listener functions/ids. The API is designed this way to discourage these\n * propagation strategies from actually executing the dispatches, since we\n * always want to collect the entire set of dispatches before executing event a\n * single one.\n *\n * @constructor EventPropagators\n */\nvar EventPropagators = {\n  accumulateTwoPhaseDispatches: accumulateTwoPhaseDispatches,\n  accumulateTwoPhaseDispatchesSkipTarget: accumulateTwoPhaseDispatchesSkipTarget,\n  accumulateDirectDispatches: accumulateDirectDispatches,\n  accumulateEnterLeaveDispatches: accumulateEnterLeaveDispatches\n};\n\nmodule.exports = EventPropagators;\n};"],
"names":["shadow$provide","global","require","module","exports","accumulateDirectionalDispatches","domID","upwards","event","warning","getListener","dispatchConfig","phasedRegistrationNames","registrationName","phase","PropagationPhases","bubbled","captured","_dispatchListeners","accumulateInto","listener","_dispatchIDs","accumulateTwoPhaseDispatchesSingle","EventPluginHub","injection","getInstanceHandle","traverseTwoPhase","dispatchMarker","accumulateTwoPhaseDispatchesSingleSkipTarget","traverseTwoPhaseSkipTarget","accumulateDispatches","id","ignoredDirection","accumulateDirectDispatchesSingle","EventConstants","forEachAccumulated","EventPropagators","accumulateTwoPhaseDispatches","events","accumulateTwoPhaseDispatchesSkipTarget","accumulateDirectDispatches","accumulateEnterLeaveDispatches","leave","enter","fromID","toID","traverseEnterLeave"]
}
