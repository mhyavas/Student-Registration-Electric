{"version":3,"sources":["wip/demo_todos_advanced.cljc"],"mappings":";AA+BA,GAAA,QAAAA,gCAAAC,oDAAAC;AAAA;AAAA,AAAA,qCAAA,rCAASC;;AAET,AAGA,GAAA,QAAAH,gCAAAC,oDAAAG;AAAA;AAAA,AAAA,mCAAA,nCAASC;;AAGT,GAAA,QAAAL,gCAAAC,oDAAAK;AAAA;AAAA,AAAA,sCAAA,tCAASC;;AAUT,AAGA,AAUA,AAEA,AAMA,AAYA,AAAKC,wCAAQ,AAACC,gDAAQC,qBAAKC;AAE3B,AAMA,AASA,AAKA,AASA","names":["js/wip","js/wip.demo-todos-advanced","js/wip.demo-todos-advanced.!conn","wip.demo-todos-advanced/!conn","js/wip.demo-todos-advanced.!db","wip.demo-todos-advanced/!db","js/wip.demo-todos-advanced.!taker","wip.demo-todos-advanced/!taker","wip.demo-todos-advanced/tempid?","cljs.core.some_fn","cljs.core/nil?","cljs.core/string?"],"sourcesContent":["(ns wip.demo-todos-advanced\r\n  (:import [hyperfiddle.electric Pending])\r\n  (:require #?(:clj [datomic.api :as d]) ; database on server\r\n            [hyperfiddle.electric :as e]\r\n            [hyperfiddle.electric-dom2 :as dom]\r\n            [missionary.core :as m]\r\n            [hyperfiddle.electric-ui4 :as ui]\r\n            [hyperfiddle.electric-ui5 :as ui5]\r\n            [contrib.data]\r\n            [contrib.debug :as dbg]))\r\n\r\n;; showcases how to render an item optimistically and without e/for-event\r\n;; missing:\r\n;; - ordering\r\n;; - idempotent entity creation\r\n;; - integration of a local and remote seq in e/for-by\r\n\r\n#?(:clj\r\n   (def schema\r\n     [{:db/ident :task/status,      :db/valueType :db.type/keyword, :db/cardinality :db.cardinality/one}\r\n      {:db/ident :task/description, :db/valueType :db.type/string,  :db/cardinality :db.cardinality/one}\r\n      {:db/ident :hf/stable-id,     :db/valueType :db.type/uuid,    :db/cardinality :db.cardinality/one, :db/unique :db.unique/identity}]))\r\n\r\n#?(:clj (defn init-conn []\r\n          (let [uri \"datomic:mem://db\"]\r\n            (d/delete-database uri)\r\n            (d/create-database uri)\r\n            (let [conn (d/connect uri)]\r\n              (d/transact conn schema)\r\n              conn))))\r\n\r\n(defonce !conn #?(:clj (init-conn) :cljs nil)) ; database on server\r\n#?(:clj (comment (alter-var-root #'!conn (fn [_] (init-conn)))))\r\n(e/def db)\r\n\r\n; injected database ref; Electric defs are always dynamic\r\n(defonce !db #?(:clj (atom nil) :cljs nil))\r\n;; singleton database queue polling\r\n;; in the future this can be done with `m/signal`\r\n(defonce !taker #?(:clj (future\r\n                          (reset! !db (d/db !conn))\r\n                          (let [q (d/tx-report-queue !conn)]\r\n                            (loop []\r\n                              (reset! !db (:db-after (.take ^java.util.concurrent.LinkedBlockingQueue q)))\r\n                              (recur))))\r\n                   :cljs nil))\r\n\r\n;; user configurable latency and tx fail rate\r\n#?(:clj (def !latency (atom 200)))\r\n(e/def latency (e/server (e/watch !latency)))\r\n\r\n#?(:clj (def !fail-rate (atom 1)))\r\n(e/def fail-rate (e/server (e/watch !fail-rate)))\r\n\r\n;; tx with configured latency and fail rate\r\n#?(:clj (defn tx! [tx]\r\n          (m/sp\r\n            (m/? (m/sleep @!latency))\r\n            (if (< (rand-int 10) @!fail-rate)\r\n              (throw (ex-info \"tx failed\" {:tx tx}))\r\n              @(d/transact !conn (dbg/dbg :tx tx))))))\r\n\r\n(e/def Tx!)\r\n\r\n(e/defn Latency [min max]\r\n  (dom/span (dom/style {:display \"inline-flex\", :flex-direction \"column\"})\r\n    (dom/span (dom/text \"Latency: \" latency \"ms\"))\r\n    (ui/range latency (e/fn [v] (e/server (reset! !latency v)))\r\n      (dom/props {:min min, :max max, :style {:width \"200px\"}}))))\r\n\r\n(e/defn FailRate [min max]\r\n  (dom/span (dom/style {:display \"inline-flex\", :flex-direction \"column\"})\r\n    (dom/span (dom/text \"Fail Rate: \" fail-rate \" out of \" max))\r\n    (ui/range fail-rate (e/fn [v] (e/server (reset! !fail-rate v)))\r\n      (dom/props {:min min, :max max, :style {:width \"200px\"}}))))\r\n\r\n#?(:clj (defn todo-count [db] (count (d/q '[:find [?e ...] :where [?e :task/status :active]] db))))\r\n\r\n#?(:clj (defn todo-records [db]\r\n          (d/q '[:find [(pull ?e [:db/id :task/description :task/status :hf/stable-id]) ...]\r\n                 :where [?e :task/status]] db)))\r\n\r\n(def tempid? (some-fn nil? string?))\r\n\r\n(e/defn ReadEntity [id]\r\n  (try\r\n    (e/server [::e/init (into {} (d/touch (d/entity db id)))])\r\n    (catch Pending _ [::e/pending nil])\r\n    (catch :default e [::e/failed e])))\r\n\r\n(e/defn CreateEntity [id record]\r\n  (try ; create is never ::e/init\r\n    (e/server\r\n      (when-not (d/entity db id)\r\n        (case (new Tx! [record])     ; returns tx-report which has :ids->tempids\r\n          [::e/ok (into {} (d/touch (d/entity db id)))])))\r\n    (catch Pending _ [::e/pending record]) ; optimistic\r\n    (catch :default e [::e/failed e])))\r\n\r\n(e/defn EnsureEntity [id record]\r\n  (if-not (tempid? id)\r\n    (ReadEntity. id)\r\n    (CreateEntity. id record))) ; todo must be idempotent\r\n\r\n(e/defn TodoItem [record]\r\n  (e/client\r\n    (dom/div (dom/style {:display \"flex\", :align-items \"center\"})\r\n      (ui5/entity record EnsureEntity\r\n        (ui5/checkbox (= :done (:task/status record))\r\n          (e/fn [checked?] (e/server (new Tx! [[:db/add (:db/id record) :task/status (if checked? :done :active)]]))))\r\n        (ui5/input (:task/description record)\r\n          (e/fn [v] (e/server (new Tx! [[:db/add (:db/id record) :task/description v]]))))))))\r\n\r\n(e/defn AdvancedTodoList []\r\n  (e/server\r\n    (binding [db (e/watch !db), Tx! (e/fn [tx] (new (e/task->cp (tx! tx))) nil)]\r\n      ;; (d/transact !conn schema)\r\n      (e/client\r\n        (dom/h1 (dom/text \"advanced todo list with optimistic render and fail/retry\"))\r\n        (dom/p (dom/text \"it's multiplayer, try two tabs\"))\r\n        (Latency. 0 2000)\r\n        (FailRate. 0 10)\r\n        (dom/div (dom/props {:class \"todo-list\"})\r\n          ;(dom/div {:class \"todo-items\"})\r\n          (let [optimistic-records\r\n                (dom/input (dom/props {:placeholder \"Buy milk\"}) ; todo move into TodoItem\r\n                  (->> (m/observe (fn [!] (e/dom-listener dom/node \"keydown\" #(some-> (ui/?read-line! dom/node %) !) {})))\r\n                    (m/eduction (map (fn [input-val]\r\n                                       (let [id (random-uuid)]\r\n                                         {:hf/stable-id id\r\n                                          :task/description input-val\r\n                                          :task/status :active}))))\r\n                    (m/reductions conj [])\r\n                    new))]\r\n            (e/client #_e/server   ; fixme\r\n              ;; we have a local and remote list of records\r\n              ;; we'd need to diff them on their respective peers and integrate them on the client\r\n              ;; currently we don't have this functionality so we hack it\r\n              ;; by sending the whole server collection to the client\r\n              (e/for-by :hf/stable-id [record (vals (reduce (fn [ac nx] (assoc ac (:hf/stable-id nx) nx))\r\n                                                      (contrib.data/index-by :hf/stable-id optimistic-records)\r\n                                                      (e/server (todo-records db))))]\r\n                (TodoItem. record))))\r\n          (dom/p (dom/props {:class \"counter\"})\r\n            (dom/span (dom/props {:class \"count\"}) (dom/text (e/server (todo-count db))))\r\n            (dom/text \" items left\")))))))\r\n"]}