{"version":3,"sources":["demo/demo_todomvc_branched.cljc"],"mappings":";AAoDA,AACA,AAAKA,yCAAgB,6CAAA,2CAAA,4GAAA,kDAAA,8GAAA,KAAA,0GAAA,ndAACC;AAsBtB,AAMA,AAmBA,AA6CA,AAkBA,AAQA,AASA,AAOA,AAWA,AA6BA","names":["demo.demo-todomvc-branched/!state","cljs.core.atom"],"sourcesContent":["(ns demo.demo-todomvc-branched\r\n  \"Requires -Xss2m to compile. The Electric compiler exceeds the default 1m JVM ThreadStackSize\r\n  due to large macroexpansion resulting in false StackOverflowError during analysis.\"\r\n  (:require\r\n   #?(:clj [contrib.datomic-contrib :as dx])\r\n   #?(:clj [datomic.api :as d])\r\n   [contrib.debug :as dbg]\r\n   contrib.str\r\n   [hyperfiddle.api :as hf]\r\n   [hyperfiddle.electric :as e]\r\n   [hyperfiddle.electric-dom2 :as dom]\r\n   [hyperfiddle.electric-ui4 :as ui]\r\n   [missionary.core :as m]))\r\n\r\n;;; Datomic plumbing\r\n#?(:clj\r\n   (defn next-db< [conn]\r\n     (let [q (d/tx-report-queue conn)]\r\n       (m/observe (fn [!]\r\n                    (! (d/db conn))\r\n                    (let [t (Thread. ^Runnable\r\n                              #(when (try (! (:db-after (.take ^java.util.concurrent.LinkedBlockingQueue q)))\r\n                                          true\r\n                                          (catch InterruptedException _))\r\n                                 (recur)))]\r\n                      (.start t)\r\n                      #(doto t .interrupt .join)))))))\r\n\r\n;; Datomic only allows a single queue consumer, so we need to spawn a singleton here\r\n;; In the next Electric iteration we can use `m/signal` and clean this up\r\n#?(:clj (defonce !db (atom nil)))\r\n#?(:clj (defonce !taker nil))\r\n#?(:clj (defn init-conn [schema]\r\n          (let [uri \"datomic:mem://todomvc-branched\"]\r\n            (d/delete-database uri)\r\n            (d/create-database uri)\r\n            (let [conn (d/connect uri)]\r\n              (d/transact conn schema)\r\n              (when !taker (!taker))\r\n              (alter-var-root #'!taker (fn [_] ((m/reduce #(reset! !db %2) nil (next-db< conn)) identity identity)))\r\n              conn))))\r\n\r\n;; Application\r\n#?(:clj\r\n   (def schema\r\n     [{:db/ident :task/status,      :db/valueType :db.type/keyword, :db/cardinality :db.cardinality/one}\r\n      {:db/ident :task/description, :db/valueType :db.type/string,  :db/cardinality :db.cardinality/one}]))\r\n\r\n\r\n#?(:clj (defonce !conn (init-conn schema)))\r\n#?(:clj (comment (alter-var-root #'!conn (fn [_] (init-conn schema)))))\r\n\r\n(e/def db)                                                  ; server\r\n(def !state #?(:cljs (atom {::filter :all                   ; client\r\n                            ::editing nil\r\n                            ::delay   0})))\r\n\r\n#?(:clj\r\n   (defn query-todos [db filter]\r\n     {:pre [filter]}\r\n     (case filter\r\n       :active (d/q '[:find [?e ...] :where [?e :task/status :active]] db)\r\n       :done   (d/q '[:find [?e ...] :where [?e :task/status :done]] db)\r\n       :all    (d/q '[:find [?e ...] :where [?e :task/status]] db))))\r\n\r\n#?(:clj\r\n   (defn todo-count [db filter]\r\n     {:pre  [filter]\r\n      :post [(number? %)]}\r\n     (-> (case filter\r\n           :active (d/q '[:find (count ?e) . :where [?e :task/status :active]] db)\r\n           :done   (d/q '[:find (count ?e) . :where [?e :task/status :done]] db)\r\n           :all    (d/q '[:find (count ?e) . :where [?e :task/status]] db))\r\n       (or 0)))) ; datascript can return nil wtf\r\n\r\n(e/defn Filter-control [state target label]\r\n  (dom/a (dom/props {:class (when (= state target) \"selected\")})\r\n    (dom/text label)\r\n    (dom/on \"click\" (e/fn [_] (swap! !state assoc ::filter target)))))\r\n\r\n\r\n(e/defn TodoStats [state]\r\n  (let [active (e/server (todo-count hf/db :active))\r\n        done   (e/server (todo-count hf/db :done))]\r\n    (dom/div\r\n      (dom/span (dom/props {:class \"todo-count\"})\r\n        (dom/strong (dom/text active))\r\n        (dom/span (dom/text \" \" (str (case active 1 \"item\" \"items\")) \" left\")))\r\n\r\n      (dom/ul (dom/props {:class \"filters\"})\r\n        (dom/li (Filter-control. (::filter state) :all \"All\"))\r\n        (dom/li (Filter-control. (::filter state) :active \"Active\"))\r\n        (dom/li (Filter-control. (::filter state) :done \"Completed\")))\r\n\r\n      (when (pos? done)\r\n        (ui/button (e/fn [] (e/server (when-some [ids (seq (query-todos hf/db :done))]\r\n                                          (hf/Transact!. (mapv (fn [id] [:db/retractEntity id]) ids)) nil)))\r\n          (dom/props {:class \"clear-completed\"})\r\n          (dom/text \"Clear completed \" done))))))\r\n\r\n(e/defn TodoItem [state id]\r\n  (e/server\r\n    ;; we'd use `d/entity` is not for this Datomic bug\r\n    ;; https://ask.datomic.com/index.php/859/equality-on-d-entity-ignores-db?show=859#q859\r\n    (let [{:keys [:task/status :task/description]} (d/pull hf/db '[:task/status :task/description] id)]\r\n      (e/client\r\n        (dom/li\r\n          (dom/props {:class [(when (= :done status) \"completed\")\r\n                              (when (= id (::editing state)) \"editing\")]})\r\n          (dom/div (dom/props {:class \"view\"})\r\n            (ui/checkbox (= :done status) (e/fn [v]\r\n                                              (let [status (case v true :done, false :active, nil)]\r\n                                                (e/server (hf/Transact!. [{:db/id id, :task/status status}]) nil)))\r\n              (dom/props {:class \"toggle\"}))\r\n            (dom/label (dom/text description)\r\n                       (dom/on \"dblclick\" (e/fn [_] (swap! !state assoc ::editing id)))))\r\n          (when (= id (::editing state))\r\n            (dom/span (dom/props {:class \"input-load-mask\"})\r\n              (dom/on-pending (dom/props {:aria-busy true})\r\n                (dom/input\r\n                  (dom/on \"keydown\"\r\n                    (e/fn [e]\r\n                      (case (.-key e)\r\n                        \"Enter\" (when-some [description (contrib.str/blank->nil (-> e .-target .-value))]\r\n                                  (case (e/server (hf/Transact!. [{:db/id id, :task/description description}]) nil)\r\n                                    (swap! !state assoc ::editing nil)))\r\n                        \"Escape\" (swap! !state assoc ::editing nil)\r\n                        nil)))\r\n                  (dom/on \"blur\"\r\n                    (e/fn [e]\r\n                      (when-some [description (contrib.str/blank->nil (-> e .-target .-value))]\r\n                        (case (e/server (hf/Transact!. [{:db/id id, :task/description description}]) nil)\r\n                          (swap! !state assoc ::editing nil)))))\r\n                  (dom/props {:class \"edit\" #_#_:autofocus true})\r\n                  (dom/bind-value description) ; first set the initial value, then focus\r\n                  (case description ; HACK sequence - run focus after description is available\r\n                    (.focus dom/node))))))\r\n          (ui/button (e/fn [] (e/server (hf/Transact!. [[:db/retractEntity id]]) nil))\r\n            (dom/props {:class \"destroy\"})))))))\r\n\r\n#?(:clj\r\n   (defn toggle-all! [db status]\r\n     (let [ids    (query-todos db (if (= :done status) :active :done))]\r\n       (map (fn [id] {:db/id id, :task/status status}) ids))))\r\n\r\n(e/defn TodoList [state]\r\n  (e/client\r\n    (dom/div\r\n      (dom/section (dom/props {:class \"main\"})\r\n        (let [active (e/server (todo-count hf/db :active))\r\n              all    (e/server (todo-count hf/db :all))\r\n              done   (e/server (todo-count hf/db :done))]\r\n          (ui/checkbox (cond (= all done)   true\r\n                             (= all active) false\r\n                             :else          nil)\r\n            (e/fn [v] (let [status (case v (true nil) :done, false :active)]\r\n                        (e/server (hf/Transact!. (toggle-all! hf/db status)) nil)))\r\n            (dom/props {:class \"toggle-all\"})))\r\n        (dom/label (dom/props {:for \"toggle-all\"}) (dom/text \"Mark all as complete\"))\r\n        (dom/ul (dom/props {:class \"todo-list\"})\r\n          (e/for [id (e/server (sort (query-todos hf/db (::filter state))))]\r\n            (TodoItem. state id)))))))\r\n\r\n(e/defn CreateTodo []\r\n  (dom/span (dom/props {:class \"input-load-mask\"})\r\n    (dom/on-pending (dom/props {:aria-busy true})\r\n      (dom/input\r\n        (ui/on-submit (e/fn [description]\r\n                        (e/server (hf/Transact!. [{:task/description description, :task/status :active}]) nil)))\r\n        (dom/props {:class \"new-todo\", :placeholder \"What needs to be done?\"})))))\r\n\r\n(e/defn TodoMVC-UI [state]\r\n  (dom/section (dom/props {:class \"todoapp\"})\r\n    (dom/header (dom/props {:class \"header\"})\r\n      (CreateTodo.))\r\n    (when (e/server (pos? (todo-count hf/db :all)))\r\n      (TodoList. state))\r\n    (dom/footer (dom/props {:class \"footer\"})\r\n      (TodoStats. state))))\r\n\r\n(e/defn TodoMVC-body [state]\r\n  (dom/div (dom/props {:class \"todomvc\"})\r\n    (dom/h1 (dom/text \"TodoMVC\"))\r\n    (TodoMVC-UI. state)\r\n    (dom/footer (dom/props {:class \"info\"})\r\n      (dom/p (dom/text \"Double-click to edit a todo\")))))\r\n\r\n(e/defn Diagnostics [state]\r\n  (dom/h1 (dom/text \"Diagnostics\"))\r\n  (dom/dl\r\n    (dom/dt (dom/text \"count :all\")) (dom/dd (dom/text (pr-str (e/server (todo-count hf/db :all)))))\r\n    (dom/dt (dom/text \"query :all\")) (dom/dd (dom/text (pr-str (e/server (query-todos hf/db :all)))))\r\n    (dom/dt (dom/text \"state\")) (dom/dd (dom/text (pr-str state)))\r\n    (dom/dt (dom/text \"delay\")) (dom/dd\r\n                                   (ui/long (::delay state) (e/fn [v] (swap! !state assoc ::delay v))\r\n                                     (dom/props {:step 1, :min 0, :style {:width :min-content}}))\r\n                                   (dom/text \" ms\"))))\r\n\r\n(e/defn TodoMVCBranched []\r\n  (e/client\r\n    (let [state (e/watch !state)]\r\n      (e/server\r\n        (binding [db (e/watch !db)\r\n                  hf/Transact! (e/fn [tx] (d/transact !conn tx))]\r\n          (binding [hf/schema (new (dx/schema> db))\r\n                    hf/into-tx' hf/into-tx\r\n                    hf/with (fn [db tx]\r\n                              (try (:db-after (d/with db tx))\r\n                                   (catch Throwable ex (prn ex) #_(prn [(type ex) (ex-message ex)]) db)))\r\n                    hf/db db]\r\n            (let [TransactInParent! hf/Transact!]\r\n              (hf/branch\r\n                (e/client\r\n                  (dom/link (dom/props {:rel :stylesheet, :href \"/todomvc.css\"}))\r\n                                        ; exclude #root style from todomvc-composed by inlining here\r\n                  (dom/element \"style\" (dom/text \"body.hyperfiddle { width: 65vw; margin-left: auto; margin-right: auto; }\"))\r\n                  (TodoMVC-body. state)\r\n                  #_ (Diagnostics. state)\r\n                  (dom/hr)\r\n                  (ui/button (e/fn [] (e/server (TransactInParent!. hf/stage) nil))\r\n                    (dom/text \"Commit\")\r\n                    (dom/props {:disabled (e/server (empty? hf/stage))}))\r\n                  (ui/button (e/fn [] (e/server (hf/ClearStage!.) nil))\r\n                    (dom/text \"Discard\")\r\n                    (dom/props {:disabled (e/server (empty? hf/stage))}))\r\n                  (ui/edn (e/server hf/stage) nil (dom/props {:disabled true})))))))))))\r\n\r\n(comment\r\n  (todo-count (d/db !conn) :all)\r\n  (todo-count @!conn :active)\r\n  (todo-count @!conn :done)\r\n  (query-todos @!conn :all)\r\n  (query-todos @!conn :active)\r\n  (query-todos @!conn :done)\r\n  (d/q '[:find (count ?e) . :where [?e :task/status]] @!conn)\r\n  )\r\n"]}